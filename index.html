<!DOCTYPE html>
<html lang="th">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ตัวเลขและผลลัพธ์ที่เป็นไปได้</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <!-- Navigation -->
    <div class="nav-container">
      <!-- New liquid glass segmented control -->
      <div class="nav-glass-switch">
        <div class="nav-blob"></div>
        <button class="nav-btn nav-tab active" onclick="showPage('calculation-page', this);" data-target="calculation-page">การคำนวณ</button>
        <button class="nav-btn nav-tab" onclick="showPage('settings-page', this);" data-target="settings-page">การตั้งค่า</button>
      </div>
      <div class="theme-toggle" onclick="toggleTheme()"></div>
    </div>

    <!-- Main Content -->
    <div class="main-container">
      <!-- Calculation Page -->
      <div id="calculation-page" class="page active">
        <div class="container">
          <h1>คำนวณผลลัพธ์ที่เป็นไปได้</h1>
          <p>กรอกตัวเลขและผลลัพธ์ที่ต้องการคำนวณ (number, pi, e)</p>
          <div id="numbers" class="number-container"></div>
          <button class="add-btn" onclick="addNumber()">+</button>
          <button class="remove-btn" onclick="removeNumber()">-</button>
          <br />
          <div id="target-single-box">
            <input
              type="text"
              id="target"
              placeholder="ผลลัพธ์"
              class="easy-input"
            />
          </div>
          <div id="target-range-box" style="display:none; gap:8px; align-items:center;">
            <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
              <input type="text" id="target-min" placeholder="ช่วงต่ำสุด" class="easy-input" style="min-width:120px;" />
              <span style="opacity:0.7;">ถึง</span>
              <input type="text" id="target-max" placeholder="ช่วงสูงสุด" class="easy-input" style="min-width:120px;" />
            </div>
          </div>
          <br />
          <button class="calc-btn" onclick="findSolutions()">ค้นหาคำตอบ</button>
          <div id="results"></div>
        </div>
      </div>

      <!-- Updated Settings Page -->
      <div id="settings-page" class="page">
        <div class="container">
          <h1>การตั้งค่า</h1>
          <p>ปรับแต่งการทำงานของเครื่องมือคำนวณ</p>
          
          <div class="settings-options">
            <div class="option-group">
              <h3>ตัวเลือกการคำนวณ</h3>
              <div class="operator-buttons">
                <!-- Replace * and / visible text with × and ÷ -->
                <button id="toggleAddBtn" class="toggle-btn" onclick="toggleOperator('+')">เปิดการใช้ +</button>
                <button id="toggleSubBtn" class="toggle-btn" onclick="toggleOperator('-')">เปิดการใช้ -</button>
                <button id="toggleMulBtn" class="toggle-btn" onclick="toggleOperator('*')">เปิดการใช้ ×</button>
                <button id="toggleDivBtn" class="toggle-btn" onclick="toggleOperator('/')">เปิดการใช้ ÷</button>
                <button id="toggleModBtn" class="toggle-btn" onclick="toggleOperator('%')">เปิดการใช้ mod</button>
                <button id="togglePowBtn" class="toggle-btn" onclick="toggleOperator('^')">เปิดการใช้ ^</button>
                <button id="toggleConcatBtn" class="toggle-btn" onclick="toggleOperator('||')">เปิดการใช้ concat</button>
                <button id="toggleSumBtn" class="toggle-btn" onclick="toggleOperator('∑')">เปิดการใช้ ∑</button>
                <div id="sigma-formula-container" class="sigma-formula-container" style="display:none; margin-top:8px;">
                  <div class="sigma-formula-row">
                    <label for="sigma-formula" class="sigma-formula-label">สูตร f(i) สำหรับ ∑</label>
                    <input
                      type="text"
                      id="sigma-formula"
                      class="sigma-formula-input"
                      value="i"
                      placeholder="เช่น i, i*i, i^2+1"
                      inputmode="text"
                      autocapitalize="none"
                      autocomplete="off"
                      autocorrect="off"
                      spellcheck="false"
                      onchange="updateSigmaFormula()"
                    />
                  </div>
                  <div id="sigma-toolbar" class="sigma-toolbar" aria-label="Sigma tokens toolbar"></div>
                  <div class="sigma-hint">ใช้ตัวแปร i, ตัวเลข, วงเล็บ และ + − × ÷ % ^ sqrt(i) ได้</div>
                </div>
                <br>
                <button id="toggleSqrtBtn" class="toggle-btn" onclick="toggleOperator('√')">เปิดการใช้ √</button>
                <div id="sqrt-depth-container" class="sqrt-depth-container">
                  <label for="sqrt-depth">ระดับการซ้อน √ สูงสุด: </label>
                  <input
                    type="number"
                    id="sqrt-depth"
                    class="sqrt-depth-input"
                    min="1"
                    value="1"
                    onchange="updateMaxSqrtDepth()"
                  />
                </div>
                <button id="toggleFactBtn" class="toggle-btn" onclick="toggleOperator('!')">เปิดการใช้ !</button>
                <div id="fact-depth-container" class="fact-depth-container" style="display:none;">
                  <label for="fact-depth">ระดับการซ้อน ! สูงสุด: </label>
                  <input
                    type="number"
                    id="fact-depth"
                    class="fact-depth-input"
                    min="1"
                    value="1"
                    onchange="updateMaxFactDepth()"
                  />
                </div>
                <!-- NEW log operator -->
                <button id="toggleLogBtn" class="toggle-btn" onclick="toggleOperator('log')">เปิดการใช้ log</button>
                <div id="log-depth-container" class="log-depth-container" style="display:none;">
                  <label for="log-depth">ระดับการซ้อน log สูงสุด: </label>
                  <input type="number" id="log-depth" class="log-depth-input" min="1" value="1" onchange="updateMaxLogDepth()" />
                </div>
                <!-- NEW ln operator -->
                <button id="toggleLnBtn" class="toggle-btn" onclick="toggleOperator('ln')">เปิดการใช้ ln</button>
                <div id="ln-depth-container" class="log-depth-container" style="display:none;">
                  <label for="ln-depth">ระดับการซ้อน ln สูงสุด: </label>
                  <input type="number" id="ln-depth" class="log-depth-input" min="1" value="1" onchange="updateMaxLnDepth()" />
                </div>
              </div>
              <button id="toggleFastModeBtn" onclick="toggleFastMode()" class="toggle-btn mode-btn">เปิดโหมดหาคำตอบเร็ว</button>
              <div id="fast-accuracy-container" class="fast-accuracy-container" style="display:none; margin-top:8px;">
                <label for="fast-accuracy-slider" style="display:block; font-size:0.9rem; margin-bottom:4px;">ปรับสมดุล: ความเร็ว ←→ ความแม่น</label>
                <input type="range" id="fast-accuracy-slider" min="0" max="100" value="60" oninput="updateFastAccuracyLabel()" />
                <div id="fast-accuracy-label" style="font-size:0.8rem; margin-top:2px; opacity:0.8;">สมดุล (60)</div>
              </div>
              <button id="toggleIntegerModeBtn" onclick="toggleIntegerMode()" class="toggle-btn mode-btn">เปิดโหมดจำนวนเต็ม</button>
              <button id="toggleCleanModeBtn" onclick="toggleCleanMode()" class="toggle-btn mode-btn">เปิดโหมดคลีน</button>
              <button id="toggleSubsetModeBtn" onclick="toggleSubsetMode()" class="toggle-btn mode-btn">เปิดโหมดใช้บางตัวเลขได้</button>
              <button id="toggleAnalyzeModeBtn" onclick="toggleAnalyzeMode()" class="toggle-btn mode-btn">เปิดโหมดวิเคราะห์ช่วงผลลัพธ์</button>
            </div>
            
          </div>
        </div>
      </div>
    </div>

    <!-- JavaScript -->
    <script src="wasm-math.js"></script>
    <script>
// --- Fraction (Hybrid) Support (non-invasive) ---
// Stores user-entered fractions for pretty display and post-process conversion only.
// Does NOT change core evaluation math (still uses floats internally).
(function(){
  const fractionStore = new Map(); // originalString -> { n, d, value }
  const FRACTION_TOKEN = /^(\s*[+-]?\d+\s*)\/(\s*[+-]?\d+\s*)$/;
  function gcd(a,b){ a=Math.abs(a); b=Math.abs(b); while(b){ const t=a%b; a=b; b=t; } return a||1; }
  function simplify(n,d){ if(d===0) return null; if(d<0){ n=-n; d=-d; } const g=gcd(n,d); return { n:n/g, d:d/g, value: n/d }; }
  function parseFractionLiteral(str){ if(!str) return null; const m=str.match(FRACTION_TOKEN); if(!m) return null; let n=parseInt(m[1]); let d=parseInt(m[2]); if(!Number.isFinite(n)||!Number.isFinite(d)||d===0) return null; return simplify(n,d); }
  // Hook parseNumberInput by wrapping original
  if(!window.__originalParseNumberInput){
    window.__originalParseNumberInput = parseNumberInput;
    window.__fractionStore = fractionStore;
    window.parseNumberInput = function(s){
      if(typeof s === 'string'){
        const fx = parseFractionLiteral(s);
        if(fx){
          const key = s.trim();
            fractionStore.set(key, fx);
            return fx.value; // internal still float
        }
      }
      return window.__originalParseNumberInput(s);
    };
  }
  // Try to recover fraction for a numeric value using original token table
  function valueToFractionString(exprPart){
    // exprPart may be raw number string in serialized expression.
    if(typeof exprPart !== 'string') return null;
    const trimmed = exprPart.trim();
    if(fractionStore.has(trimmed)){
      const f = fractionStore.get(trimmed); return f.d===1? `${f.n}` : `${f.n}/${f.d}`;
    }
    return null;
  }
  // Public helper to attempt formatting a number (float) to a known fraction entered by user
  window.tryFormatKnownFraction = function(num){
    // exact match from store (by value) when unique
  let found=null; fractionStore.forEach(f=>{ if(Math.abs(f.value - num) < 1e-12){ if(!found) found=f; } });
    if(found){ return found.d===1? `${found.n}` : `${found.n}/${found.d}`; }
    return null;
  };
  // Lightweight float -> fraction approximation (continued fraction) for nicer output (bounded denominator)
  window.approxFraction = function(x, maxDen=2000, eps=1e-10){
    if(!Number.isFinite(x)) return null; let sign = x<0?-1:1; x=Math.abs(x);
    if(Math.abs(x-Math.round(x))<eps) return { n:sign*Math.round(x), d:1 };
    let h1=1,h0=0,k1=0,k0=1; let b=x; let iter=0;
    while(iter<50){ const a=Math.floor(b); const h2=a*h1+h0; const k2=a*k1+k0; if(k2>maxDen) break; const val=h2/k2; if(Math.abs(val - x) < eps) return { n:sign*h2, d:k2 }; h0=h1; h1=h2; k0=k1; k1=k2; b=1/(b-a); if(!isFinite(b)) break; iter++; }
    return null;
  };
  // Patch prettyPrintExpression to substitute leaf numbers if they correspond to entered fractions
  if(!window.__originalPrettyPrintExpression){
    window.__originalPrettyPrintExpression = prettyPrintExpression;
    window.prettyPrintExpression = function(expr){
      let s = window.__originalPrettyPrintExpression(expr);
      // Replace standalone decimals with known entered fraction tokens (only if they appear exactly)
      fractionStore.forEach(f=>{
        const fracStr = f.d===1? `${f.n}` : `${f.n}/${f.d}`;
        // If user typed "1/2" original serialized leaf likely "0.5"; attempt replacement on boundaries
        const decimal = f.value.toString();
        // Loose pattern: number boundaries (start, space, operator, parenthesis)
        const pattern = new RegExp(`(?<![0-9A-Za-z_/])${decimal.replace(/[-/\\^$*+?.()|[\]{}]/g,'\\$&')}(?![0-9A-Za-z_/])`,'g');
        s = s.replace(pattern, fracStr);
      });
      return s;
    };
  }
  // Enhance displayNumber formatting without breaking existing formatNumber
  if(!window.__originalFormatNumber){
    window.__originalFormatNumber = formatNumber;
    window.formatNumber = function(n){
      const direct = window.tryFormatKnownFraction(n);
      if(direct) return direct; // exact user-entered fraction
      const approx = window.approxFraction(n, 200, 1e-10);
      if(approx && approx.d>1 && Math.abs(approx.n/approx.d - n) < 1e-10){
        return `${approx.n}/${approx.d}`; // show reduced form
      }
      return window.__originalFormatNumber(n);
    };
  }
})();

// Page Navigation (refactored to avoid reliance on global event)
function showPage(pageId, sourceBtn=null) {
  // switch page visibility
  document.querySelectorAll('.page').forEach(p=>p.classList.remove('active'));
  const pageEl = document.getElementById(pageId);
  if(pageEl) pageEl.classList.add('active');
  // update active nav button
  const buttons = document.querySelectorAll('.nav-glass-switch .nav-btn');
  buttons.forEach(btn=>btn.classList.remove('active'));
  let targetBtn = sourceBtn || document.querySelector(`.nav-glass-switch .nav-btn[data-target="${pageId}"]`);
  if(targetBtn) targetBtn.classList.add('active');
  // sync blob position after layout
  requestAnimationFrame(()=> updateNavBlob());
}

// Core variables
let operatorFlags = { '+': true, '-': true, '*': true, '/': true, '%': false, '^': false, '√': false, '!': false, '||': false, '∑': false, 'log': false, 'ln': false };// added log, ln
let useFastMode = false;
let useIntegerMode = false;
let useCleanMode = false; // NEW: efficiency / clean mode
let useSubsetMode = false; // NEW: subset mode allowing partial use
let useAnalyzeMode = false; // NEW: analyze integers in range
// Added: speed-accuracy tuning (0=สุดเร็ว,1=สุดแม่น)
let fastAccuracy = 0.60; // default bias to slightly accuracy
let isCalculating = false;
let cancelCalculation = false;
let activeWorkers = [];
let MAX_SQRT_DEPTH = 1;
let MAX_FACT_DEPTH = 1;
let MAX_LOG_DEPTH = 1;
let MAX_LN_DEPTH = 1;
let SIGMA_FORMULA = 'i'; // NEW: summand formula for sigma
const MAX_FACTORIAL_INPUT = 12;
const MAX_RESULTS = 100;
const CHUNK_SIZE = 20;
const MAX_INPUT_NUMBERS = 8;
// NEW: track calculation start time
let calcStartTime = 0;

const factorialCache = new Map();
const calculationCache = new Map();
const expressionCache = new Map();

// UI Control Functions
// Start in Light theme (now acts as low-power mode by CSS)
document.body.classList.add('light-theme');

function toggleTheme() {
  document.body.classList.toggle('light-theme');
  document.body.classList.toggle('dark-theme');
  // ensure blob still aligned after theme transition
  setTimeout(updateNavBlob, 300);
}

function displayOperatorLabel(op){
  if(op==='*') return '×';
  if(op=== '/') return '÷';
  if(op=== '%') return 'mod';
  if(op==='||') return 'concat';
  if(op==='∑') return '∑';
  if(op==='ln') return 'ln';
  return op;
}

function toggleOperator(op) {
  operatorFlags[op] = !operatorFlags[op];
  const btn = document.getElementById(`toggle${op === '+' ? 'Add' : op === '-' ? 'Sub' : op === '*' ? 'Mul' : op === '/' ? 'Div' : op === '%' ? 'Mod' : op === '^' ? 'Pow' : op === '√' ? 'Sqrt' : op === '!' ? 'Fact' : op === '||' ? 'Concat' : op === '∑' ? 'Sum' : op === 'log' ? 'Log' : op === 'ln' ? 'Ln' : 'UNKNOWN'}Btn`);
  const disp = displayOperatorLabel(op);
  if (operatorFlags[op]) {
    btn.textContent = `ปิดการใช้ ${disp}`;
    btn.classList.add('active');
    if (op === '√') document.getElementById("sqrt-depth-container").classList.add("active");
    if (op === '!') document.getElementById("fact-depth-container").style.display = "block";
  if (op === 'log') document.getElementById('log-depth-container').style.display = 'block';
  if (op === 'ln') document.getElementById('ln-depth-container').style.display = 'block';
  if (op === '∑') { const el = document.getElementById('sigma-formula-container'); if(el) el.style.display='block'; }
  } else {
    btn.textContent = `เปิดการใช้ ${disp}`;
    btn.classList.remove('active');
    if (op === '√') document.getElementById("sqrt-depth-container").classList.remove("active");
    if (op === '!') document.getElementById("fact-depth-container").style.display = "none";
  if (op === 'log') document.getElementById('log-depth-container').style.display = 'none';
  if (op === 'ln') document.getElementById('ln-depth-container').style.display = 'none';
  if (op === '∑') { const el = document.getElementById('sigma-formula-container'); if(el) el.style.display='none'; }
  }
}

document.getElementById("toggleAddBtn").classList.add('active');
document.getElementById("toggleSubBtn").classList.add('active');
document.getElementById("toggleMulBtn").classList.add('active');
document.getElementById("toggleDivBtn").classList.add('active');

function updateNavBlob(){
  if(window.navDragging) return; // อย่าบังคับตำแหน่งระหว่างลาก
  const switchEl = document.querySelector('.nav-glass-switch');
  const blob = switchEl?.querySelector('.nav-blob');
  const active = switchEl?.querySelector('.nav-btn.active');
  if(!blob || !active || !switchEl) return;
  const rect = active.getBoundingClientRect();
  const parentRect = switchEl.getBoundingClientRect();
  const left = rect.left - parentRect.left;
  if(typeof window.prevBlobLeft === 'undefined') window.prevBlobLeft = left;
  const delta = left - window.prevBlobLeft;
  const adelta = Math.abs(delta);
  blob.classList.remove('squish-light','squish-medium','squish-strong');
  if(adelta > 60) blob.classList.add('squish-strong');
  else if(adelta > 25) blob.classList.add('squish-medium');
  else blob.classList.add('squish-light');
  blob.style.width = rect.width + 'px';
  blob.style.setProperty('--blob-x', left + 'px');
  window.prevBlobLeft = left;
}

window.addEventListener('resize', ()=> requestAnimationFrame(updateNavBlob));
window.addEventListener('orientationchange', ()=> setTimeout(updateNavBlob,150));
window.addEventListener('load', ()=> setTimeout(updateNavBlob,50));

function toggleFastMode() {
  useFastMode = !useFastMode;
  const btn = document.getElementById("toggleFastModeBtn");
  const container = document.getElementById('fast-accuracy-container');
  if (useFastMode) {
    btn.textContent = "ปิดโหมดหาคำตอบเร็ว";
    btn.classList.add('active-mode');
    container.style.display = 'block';
  } else {
    btn.textContent = "เปิดโหมดหาคำตอบเร็ว";
    btn.classList.remove('active-mode');
    container.style.display = 'none';
  }
}
function updateFastAccuracyLabel(){
  const slider = document.getElementById('fast-accuracy-slider');
  if(!slider) return;
  fastAccuracy = slider.value/100; // 0..1
  const timeBudgetSec = (slider.value/5).toFixed(2); // explicit mapping 0..20s
  // sync filled gradient length
  slider.style.setProperty('--progress', fastAccuracy.toString());
  let txt;
  if(fastAccuracy < 0.15) txt='เร็วที่สุด';
  else if(fastAccuracy < 0.35) txt='เร็วมาก';
  else if(fastAccuracy < 0.55) txt='ค่อนข้างเร็ว';
  else if(fastAccuracy < 0.70) txt='สมดุล';
  else if(fastAccuracy < 0.85) txt='ค่อนข้างแม่น';
  else if(fastAccuracy < 0.95) txt='แม่นมาก';
  else txt='แม่นสูงสุด';
  // Show explicit time budget mapping
  document.getElementById('fast-accuracy-label').textContent = `${txt} (${slider.value}) • เวลา ≤ ${timeBudgetSec}s`;
}
// init label once
updateFastAccuracyLabel();

(function(){
  const slider = document.getElementById('fast-accuracy-slider');
  if(!slider) return;

  const isiOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform==='MacIntel' && navigator.maxTouchPoints>1);

  // Internal state
  let isDown = false; let lastX=null; let lastT=null; let velocity=0; let rafDecay=null; let frame=null;
  const MAX_ABS_V = 3200; // clamp
  const MIN_ABS_V = 18;
  const BASE_STRETCH = 0.24; // magnitude scaling
  const DECAY = 0.88; // velocity decay per frame
  let recoilAnimating=false, recoilStart=0; const RECOIL_MS=380;

  function setVar(name,val){ slider.style.setProperty(name,val); }
  function startRecoil(){
    recoilAnimating=true; recoilStart=performance.now();
    // initial overshoot (tall & narrow)
    setVar('--recoil-x','0.78');
    setVar('--recoil-y','1.22');
    requestAnimationFrame(stepRecoil);
  }
  function stepRecoil(){
    if(!recoilAnimating) return;
    const now=performance.now();
    const t=Math.min(1,(now-recoilStart)/RECOIL_MS);
    // ease out elastic-ish
    // custom curve: blend of easeOutCubic and small damping oscillation
    const ease = 1 - Math.pow(1-t,3);
    // damp oscillation factor
    const osc = Math.sin(t*3.4*Math.PI) * (1-t)*0.12;
    const targetX = 1; const startX=0.78; const currentX = startX + (targetX-startX)*ease + osc;
    const targetY = 1; const startY=1.22; const currentY = startY + (targetY-startY)*ease - osc*0.85;
    setVar('--recoil-x', currentX.toFixed(4));
    setVar('--recoil-y', currentY.toFixed(4));
    if(t>=1){ recoilAnimating=false; setVar('--recoil-x','1'); setVar('--recoil-y','1'); return; }
    requestAnimationFrame(stepRecoil);
  }

  function press(){ slider.classList.remove('glass-release'); slider.offsetHeight; slider.classList.add('glass-press'); }
  function release(){ slider.classList.remove('glass-press'); slider.classList.add('glass-release'); startRecoil(); }

  function getClientX(e){ return e.touches? e.touches[0].clientX : e.clientX; }

  function pointerDown(e){ if(isDown) return; isDown=true; lastX=getClientX(e); lastT=performance.now(); velocity=0; if(rafDecay) cancelAnimationFrame(rafDecay); rafDecay=null; press(); }
  function pointerMove(e){ if(!isDown) return; const now=performance.now(); const x=getClientX(e); const dt=(now-lastT)/1000; if(lastX!=null && dt>0){ const dx=x-lastX; velocity = dx/dt; applyStretch(velocity); } lastX=x; lastT=now; }
  function pointerUp(){ if(!isDown) return; isDown=false; release(); if(rafDecay) cancelAnimationFrame(rafDecay); rafDecay=requestAnimationFrame(decay); }

  // Update progress custom property for blue tube (since native range won't update our gradient automatically in all engines)
  function syncProgress(){ const val=parseFloat(slider.value||0); const min=parseFloat(slider.min||0); const max=parseFloat(slider.max||100); const ratio=(val-min)/(max-min); setVar('--progress', ratio.toString()); }
  slider.addEventListener('input', syncProgress, {passive:true});
  syncProgress();

  // Events (support pointer + touch + mouse)
  slider.addEventListener('pointerdown', pointerDown, {passive:true});
  slider.addEventListener('touchstart', pointerDown, {passive:true});
  slider.addEventListener('mousedown', pointerDown, {passive:true});

  window.addEventListener('pointermove', pointerMove, {passive:true});
  window.addEventListener('touchmove', pointerMove, {passive:true});
  window.addEventListener('mousemove', pointerMove, {passive:true});

  window.addEventListener('pointerup', pointerUp, {passive:true});
  window.addEventListener('touchend', pointerUp, {passive:true});
  window.addEventListener('mouseup', pointerUp, {passive:true});
  window.addEventListener('touchcancel', pointerUp, {passive:true});

  // iOS direct transform fallback if CSS var scaling jank detected
  if(isiOS){
    // Attempt heuristic: adapt transforms via style injection each frame (here our slider thumb isn't a direct element we can easily select; for WebKit we rely on pseudo element). We'll keep CSS variable method; Safari 16+ handles it. If needed, future enhancement could use overlay custom thumb.
  }
})();

function toggleIntegerMode() {
  useIntegerMode = !useIntegerMode;
  const btn = document.getElementById("toggleIntegerModeBtn");
  if (useIntegerMode) {
    btn.textContent = "ปิดโหมดจำนวนเต็ม";
    btn.classList.add('active-mode');
  } else {
    btn.textContent = "เปิดโหมดจำนวนเต็ม";
    btn.classList.remove('active-mode');
  }
}

function toggleCleanMode(){
  useCleanMode = !useCleanMode;
  const btn = document.getElementById('toggleCleanModeBtn');
  if(useCleanMode){
    btn.textContent = 'ปิดโหมดคลีน';
    btn.classList.add('active-mode');
  } else {
    btn.textContent = 'เปิดโหมดคลีน';
    btn.classList.remove('active-mode');
  }
}
function toggleSubsetMode(){
  useSubsetMode = !useSubsetMode;
  const btn = document.getElementById('toggleSubsetModeBtn');
  if(!btn) return;
  if(useSubsetMode){ btn.textContent='ปิดโหมดใช้บางตัวเลขได้'; btn.classList.add('active-mode'); }
  else { btn.textContent='เปิดโหมดใช้บางตัวเลขได้'; btn.classList.remove('active-mode'); }
}

function toggleAnalyzeMode(){
  useAnalyzeMode = !useAnalyzeMode;
  const btn = document.getElementById('toggleAnalyzeModeBtn');
  if(!btn) return;
  if(useAnalyzeMode){ btn.textContent='ปิดโหมดวิเคราะห์ช่วงผลลัพธ์'; btn.classList.add('active-mode'); }
  else { btn.textContent='เปิดโหมดวิเคราะห์ช่วงผลลัพธ์'; btn.classList.remove('active-mode'); }
  updateTargetInputVisibility();
}

function updateTargetInputVisibility(){
  const boxSingle = document.getElementById('target-single-box');
  const boxRange = document.getElementById('target-range-box');
  if(!boxSingle || !boxRange) return;
  if(useAnalyzeMode){
    boxSingle.style.display='none';
    boxRange.style.display='flex';
    boxRange.style.justifyContent='center';
  } else {
    boxSingle.style.display='block';
    boxRange.style.display='none';
  }
}

function updateMaxSqrtDepth() {
  const input = document.getElementById("sqrt-depth");
  const value = parseInt(input.value);
  if (!isNaN(value) && value >= 1) MAX_SQRT_DEPTH = value;
  else input.value = MAX_SQRT_DEPTH;
}

function updateMaxFactDepth() {
  const input = document.getElementById("fact-depth");
  const value = parseInt(input.value);
  if (!isNaN(value) && value >= 1) MAX_FACT_DEPTH = value;
  else input.value = MAX_FACT_DEPTH;
}

function updateMaxLogDepth(){
  const input = document.getElementById('log-depth');
  const v = parseInt(input.value);
  if(!isNaN(v) && v>=1) MAX_LOG_DEPTH = v; else input.value = MAX_LOG_DEPTH;
}

function updateMaxLnDepth(){
  const input = document.getElementById('ln-depth');
  const v = parseInt(input.value);
  if(!isNaN(v) && v>=1) MAX_LN_DEPTH = v; else input.value = MAX_LN_DEPTH;
}

function updateSigmaFormula(){
  const input = document.getElementById('sigma-formula');
  if(!input) return;
  let s = (input.value || '').trim();
  if(!s) s = 'i';
  // Basic sanitation: limit length and allowed chars
  if(s.length > 64) s = s.slice(0,64);
  // Keep as-is; worker will parse/validate
  SIGMA_FORMULA = s;
  input.value = s;
}

function addNumber() {
  let numbers = document.querySelectorAll(".num-container");
  if (numbers.length < MAX_INPUT_NUMBERS) {
    let div = document.createElement("div");
    div.className = "num-container";
    let input = document.createElement("input");
  input.type = "text";
    input.className = "num";
  input.placeholder = "0";
    div.appendChild(input);
    document.getElementById("numbers").appendChild(div);
  }
}

function removeNumber() {
  let numbers = document.getElementById("numbers");
  if (numbers.children.length > 1) numbers.removeChild(numbers.lastChild);
}

// Basic Calculation Functions
function factorial(n) {
  if (n < 0 || n > MAX_FACTORIAL_INPUT || !Number.isInteger(n)) return NaN;
  if (n === 0 || n === 1) return 1;
  if (factorialCache.has(n)) return factorialCache.get(n);
  
  // Use WebAssembly if available
  let result;
  if (window.wasmMath && window.wasmMath.isReady) {
    result = window.wasmMath.factorial(n);
  } else {
    // JavaScript fallback
    result = 1;
    for (let i = 2; i <= n; i++) result *= i;
  }
  
  factorialCache.set(n, result);
  return result;
}

function evaluateAST(node) {
  if (node.type === "num") return node.value;
  let leftVal = node.left ? evaluateAST(node.left) : null;
  let rightVal = evaluateAST(node.right);
  const cacheKey = `${node.operator}|${leftVal}|${rightVal}`;
  if (calculationCache.has(cacheKey)) return calculationCache.get(cacheKey);
  let result;
  if (window.wasmMath && window.wasmMath.isReady) {
    switch (node.operator) {
      case "+": 
        result = operatorFlags['+'] ? window.wasmMath.add(leftVal, rightVal) : NaN; 
        break;
      case "-": 
        result = operatorFlags['-'] ? window.wasmMath.sub(leftVal, rightVal) : NaN; 
        break;
      case "*": 
        result = operatorFlags['*'] ? window.wasmMath.mul(leftVal, rightVal) : NaN; 
        break;
      case "/": 
        result = operatorFlags['/'] && rightVal !== 0 ? window.wasmMath.div(leftVal, rightVal) : NaN; 
        break;
      case "%":
        if (!operatorFlags['%'] || rightVal === 0) return NaN;
        result = leftVal - rightVal * Math.floor(leftVal / rightVal);
        break;
      case "^":
        if (!operatorFlags['^']) return NaN;
        result = (leftVal === 0 && rightVal <= 0) ? (rightVal === 0 ? 1 : NaN) : window.wasmMath.pow(leftVal, rightVal);
        break;
      case "√": 
        result = operatorFlags['√'] && rightVal >= 0 ? window.wasmMath.sqrt(rightVal) : NaN; 
        break;
      case "!": 
        result = operatorFlags['!'] && rightVal <= MAX_FACTORIAL_INPUT && rightVal >= 0 && Number.isInteger(rightVal) ? window.wasmMath.factorial(rightVal) : NaN; 
        break;
      case "||": {
        if(!operatorFlags['||']) { result = NaN; break; }
        if(!Number.isInteger(leftVal) || !Number.isInteger(rightVal) || leftVal < 0 || rightVal < 0) { result = NaN; break; }
        const concatVal = parseFloat(String(Math.trunc(leftVal)) + String(Math.trunc(rightVal)));
        result = concatVal;
        break; }
      case "∑": {
        if(!operatorFlags['∑']) { result = NaN; break; }
        if(!Number.isInteger(leftVal) || !Number.isInteger(rightVal)) { result = NaN; break; }
        if(leftVal > rightVal){ result = NaN; break; }
        const n = rightVal - leftVal + 1;
        result = (leftVal + rightVal) * n / 2;
        break; }
      case "log": {
        result = operatorFlags['log'] && rightVal>0 ? Math.log10(rightVal) : NaN;
        break;
      }
      case "ln": {
        result = operatorFlags['ln'] && rightVal>0 ? Math.log(rightVal) : NaN;
        break;
      }
      default: return NaN;
    }
  } else {
    switch (node.operator) {
      case "+": result = operatorFlags['+'] ? leftVal + rightVal : NaN; break;
      case "-": result = operatorFlags['-'] ? leftVal - rightVal : NaN; break;
      case "*": result = operatorFlags['*'] ? leftVal * rightVal : NaN; break;
      case "/": result = operatorFlags['/'] && rightVal !== 0 ? leftVal / rightVal : NaN; break;
      case "%":
        if (!operatorFlags['%'] || rightVal === 0) return NaN;
        result = leftVal - rightVal * Math.floor(leftVal / rightVal); break;
      case "^":
        if (!operatorFlags['^']) return NaN;
        result = (leftVal === 0 && rightVal <= 0) ? (rightVal === 0 ? 1 : NaN) : Math.pow(leftVal, rightVal); break;
      case "√": result = operatorFlags['√'] && rightVal >= 0 ? Math.sqrt(rightVal) : NaN; break;
      case "!": result = operatorFlags['!'] && rightVal <= MAX_FACTORIAL_INPUT && rightVal >= 0 && Number.isInteger(rightVal) ? factorial(rightVal) : NaN; break;
      case "||": {
        if(!operatorFlags['||']) { result = NaN; break; }
        if(!Number.isInteger(leftVal) || !Number.isInteger(rightVal) || leftVal < 0 || rightVal < 0) { result = NaN; break; }
        result = parseFloat(String(Math.trunc(leftVal)) + String(Math.trunc(rightVal))); break; }
      case "∑": {
        if(!operatorFlags['∑']) { result = NaN; break; }
        if(!Number.isInteger(leftVal) || !Number.isInteger(rightVal) || leftVal > rightVal){ result = NaN; break; }
        const n = rightVal - leftVal + 1; result = (leftVal + rightVal) * n / 2; break; }
      case "log": {
        result = operatorFlags['log'] && rightVal>0 ? Math.log10(rightVal) : NaN;
        break;
      }
      case "ln": {
        result = operatorFlags['ln'] && rightVal>0 ? Math.log(rightVal) : NaN;
        break;
      }
      default: return NaN;
    }
  }
  if (!isNaN(result)) {
    if (calculationCache.size > 1000000) calculationCache.clear();
    calculationCache.set(cacheKey, result);
  }
  return result;
}

function isIntegerResult(result) {
  return Number.isInteger(result) || Math.abs(result - Math.round(result)) < 0.0001;
}

function serializeAST(node) {
  if (node.type === "num") return node.value.toString();
  if (node.operator === "√") return `√(${serializeAST(node.right)})`;
  if (node.operator === "!") return `(${serializeAST(node.right)})!`;
  if (node.operator === "log") return `log(${serializeAST(node.right)})`;
  if (node.operator === "ln") return `ln(${serializeAST(node.right)})`;
  return `(${node.left ? serializeAST(node.left) : ""} ${node.operator} ${serializeAST(node.right)})`;
}

function canonicalizeAST(node) {
  if (node.type === "num") return node;
  let left = node.left ? canonicalizeAST(node.left) : null;
  let right = canonicalizeAST(node.right);
  if (node.operator === "+" || node.operator === "*" || node.operator === "%") {
    let leftStr = serializeAST(left);
    let rightStr = serializeAST(right);
    if (leftStr > rightStr) return { type: "op", operator: node.operator, left: right, right: left };
  }
  return { type: "op", operator: node.operator, left, right };
}

function getSqrtDepth(node) {
  if (node.type === "num") return 0;
  if (node.operator === "√") return 1 + getSqrtDepth(node.right);
  let leftDepth = node.left ? getSqrtDepth(node.left) : 0;
  let rightDepth = node.right ? getSqrtDepth(node.right) : 0;
  return Math.max(leftDepth, rightDepth);
}

function getFactDepth(node) {
  if (node.type === "num") return 0;
  if (node.operator === "!") return 1 + getFactDepth(node.right);
  let leftDepth = node.left ? getFactDepth(node.left) : 0;
  let rightDepth = node.right ? getFactDepth(node.right) : 0;
  return Math.max(leftDepth, rightDepth);
}

function getLogDepth(node){ if(node.type==='num') return 0; if(node.operator==='log') return 1+getLogDepth(node.right); const ld=node.left?getLogDepth(node.left):0; const rd=node.right?getLogDepth(node.right):0; return Math.max(ld,rd); }
function getLnDepth(node){ if(node.type==='num') return 0; if(node.operator==='ln') return 1+getLnDepth(node.right); const ld=node.left?getLnDepth(node.left):0; const rd=node.right?getLnDepth(node.right):0; return Math.max(ld,rd); }

function generateAllGroupings(nums, target) {
  const memoized = new Map();
  function generateGroupingsHelper(start, end) {
    const key = `${start}-${end}`;
    if (memoized.has(key)) return memoized.get(key);
    const result = [];
    if (start === end) {
      const numNode = { type: "num", value: nums[start] };
      result.push(numNode);
      if (operatorFlags['√'] && nums[start] >= 0 && (!useIntegerMode || Number.isInteger(Math.sqrt(nums[start])))) {
        let currentExpr = numNode;
        for (let i = 1; i <= MAX_SQRT_DEPTH && operatorFlags['√']; i++) {
          currentExpr = { type: "op", operator: "√", left: null, right: currentExpr };
          const sqrtResult = evaluateAST(currentExpr);
            if (!isNaN(sqrtResult) && (!useIntegerMode || isIntegerResult(sqrtResult))) result.push(currentExpr);
            else break;
        }
      }
      if (operatorFlags['!'] && nums[start] >= 0 && nums[start] <= MAX_FACTORIAL_INPUT && Number.isInteger(nums[start])) {
        let currentExpr = numNode;
        for (let i = 1; i <= MAX_FACT_DEPTH && operatorFlags['!']; i++) {
          currentExpr = { type: "op", operator: "!", left: null, right: currentExpr };
          const factResult = evaluateAST(currentExpr);
          if (!isNaN(factResult)) result.push(currentExpr); else break;
        }
      }
      // NEW: base case log nesting
      if (operatorFlags['log'] && nums[start] > 0){
        let currentExpr = numNode;
        for(let i=1;i<=MAX_LOG_DEPTH && operatorFlags['log'];i++){
          currentExpr = { type:'op', operator:'log', left:null, right: currentExpr };
          const logResult = evaluateAST(currentExpr);
          if(!isNaN(logResult) && (!useIntegerMode || isIntegerResult(logResult))) result.push(currentExpr); else break;
        }
      }
      // NEW: base case ln nesting
      if (operatorFlags['ln'] && nums[start] > 0){
        let currentExpr = numNode;
        for(let i=1;i<=MAX_LN_DEPTH && operatorFlags['ln'];i++){
          currentExpr = { type:'op', operator:'ln', left:null, right: currentExpr };
          const logResult = evaluateAST(currentExpr);
          if(!isNaN(logResult) && (!useIntegerMode || isIntegerResult(logResult))) result.push(currentExpr); else break;
        }
      }
    } else {
      for (let i = start; i < end; i++) {
        const leftExprs = generateGroupingsHelper(start, i);
        const rightExprs = generateGroupingsHelper(i + 1, end);
        for (const left of leftExprs) {
          for (const right of rightExprs) {
            const operators = [];
            if (operatorFlags['+']) operators.push("+");
            if (operatorFlags['-']) operators.push("-");
            if (operatorFlags['*']) operators.push("*");
            if (operatorFlags['/']) operators.push("/");
            if (operatorFlags['%']) operators.push("%");
            if (operatorFlags['^']) operators.push("^");
            for (const op of operators) {
              if (op === "/" && evaluateAST(right) === 0) continue;
              if (op === "%" && evaluateAST(right) === 0) continue;
              if (op === "^" && evaluateAST(left) === 0 && evaluateAST(right) <= 0) continue;
              const newExpr = { type: "op", operator: op, left, right };
              const resultVal = evaluateAST(newExpr);
              if (isNaN(resultVal)) continue;
              if (!useIntegerMode || isIntegerResult(resultVal)) {
                result.push(newExpr);
                if (operatorFlags['√'] && getSqrtDepth(newExpr) < MAX_SQRT_DEPTH) {
                  const sqrtValue = evaluateAST(newExpr);
                  if (!isNaN(sqrtValue) && sqrtValue >= 0) {
                    let currentExpr = newExpr;
                    for (let depth = 1; depth <= MAX_SQRT_DEPTH - getSqrtDepth(newExpr); depth++) {
                      currentExpr = { type: "op", operator: "√", left: null, right: currentExpr };
                      const sqrtResult = evaluateAST(currentExpr);
                      if (!isNaN(sqrtResult) && (!useIntegerMode || isIntegerResult(sqrtResult))) result.push(currentExpr); else break;
                    }
                  }
                }
                if (operatorFlags['!'] && getFactDepth(newExpr) < MAX_FACT_DEPTH) {
                  const factValue = evaluateAST(newExpr);
                  if (!isNaN(factValue) && factValue >= 0 && factValue <= MAX_FACTORIAL_INPUT && Number.isInteger(factValue)) {
                    let currentExpr = newExpr;
                    for (let depth = 1; depth <= MAX_FACT_DEPTH - getFactDepth(newExpr); depth++) {
                      currentExpr = { type: "op", operator: "!", left: null, right: currentExpr };
                      const factResult = evaluateAST(currentExpr);
                      if (!isNaN(factResult)) result.push(currentExpr); else break;
                    }
                  }
                }
                // NEW: log chaining
                if (operatorFlags['log'] && getLogDepth(newExpr) < MAX_LOG_DEPTH){
                  const baseVal = evaluateAST(newExpr);
                  if(!isNaN(baseVal) && baseVal > 0){
                    let currentExpr = newExpr;
                    for(let depth=1; depth <= MAX_LOG_DEPTH - getLogDepth(newExpr); depth++){
                      currentExpr = { type:'op', operator:'log', left:null, right: currentExpr };
                      const logResult = evaluateAST(currentExpr);
                      if(!isNaN(logResult) && (!useIntegerMode || isIntegerResult(logResult))) result.push(currentExpr); else break;
                    }
                  }
                }
                // NEW: ln chaining (shares depth budget with log)
        if (operatorFlags['ln'] && getLnDepth(newExpr) < MAX_LN_DEPTH){
                  const baseVal = evaluateAST(newExpr);
                  if(!isNaN(baseVal) && baseVal > 0){
                    let currentExpr = newExpr;
          for(let depth=1; depth <= MAX_LN_DEPTH - getLnDepth(newExpr); depth++){
                      currentExpr = { type:'op', operator:'ln', left:null, right: currentExpr };
                      const logResult = evaluateAST(currentExpr);
                      if(!isNaN(logResult) && (!useIntegerMode || isIntegerResult(logResult))) result.push(currentExpr); else break;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    memoized.set(key, result);
    return result;
  }
  return generateGroupingsHelper(0, nums.length - 1);
}

// Enhanced result validation to prevent mismatched targets
function validateResultExact(result, target, tolerance = 1e-14) {
  if (!Number.isFinite(result) || !Number.isFinite(target)) return false;
  return Math.abs(result - target) <= tolerance;
}

// Flexible numeric formatting
function formatNumber(n) {
  if (Number.isInteger(n)) return n.toString();
  const s = n.toFixed(8); // high precision then trim
  return s.replace(/\.0+$/,'').replace(/(\.[0-9]*?)0+$/,'$1');
}

function parseNumberInput(s){
  if(typeof s !== 'string') return Number(s);
  const t = s.trim().toLowerCase();
  if(t === 'pi' || t === 'π') return Math.PI;
  if(t === 'e') return Math.E;
  return parseFloat(t);
}

function findSolutions() {
  if (isCalculating) return;
  isCalculating = true;
  cancelCalculation = false;
  activeWorkers = [];
  calcStartTime = performance.now(); // start timing

  const numContainers = document.querySelectorAll(".num-container");
  const nums = Array.from(numContainers)
    .map(container => parseNumberInput(container.querySelector(".num").value))
    .map(v => (isNaN(v) ? 0 : v));
  if (nums.length < 2) {
    document.getElementById("results").innerHTML = "<h2>กรุณาใส่ตัวเลขอย่างน้อย 2 ตัว</h2>";
    isCalculating = false;
    return;
  }
  // Branch: Analyze mode uses range instead of single target
  if(useAnalyzeMode){
    const minRaw = parseNumberInput(document.getElementById('target-min').value);
    const maxRaw = parseNumberInput(document.getElementById('target-max').value);
    const minI = Number.isFinite(minRaw) ? Math.ceil(minRaw) : NaN;
    const maxI = Number.isFinite(maxRaw) ? Math.floor(maxRaw) : NaN;
    if (isNaN(minI) || isNaN(maxI)){
      document.getElementById('results').innerHTML = '<h2>กรุณากรอกช่วงผลลัพธ์ (ต่ำสุด และ สูงสุด)</h2>';
      isCalculating = false; return;
    }
    if (minI > maxI){
      document.getElementById('results').innerHTML = '<h2>ช่วงไม่ถูกต้อง: ค่าต่ำสุดต้องไม่เกินค่าสูงสุด</h2>';
      isCalculating = false; return;
    }
    if (nums.length < 2) {
      document.getElementById("results").innerHTML = "<h2>กรุณาใส่ตัวเลขอย่างน้อย 2 ตัว</h2>";
      isCalculating = false; return;
    }
    document.getElementById('results').innerHTML = `
      <h2>กำลังวิเคราะห์ช่วง ${minI} ถึง ${maxI}...</h2>
      <button id="cancel-calc-btn" onclick="cancelCalculation = true; cancelAllWorkers();">ยกเลิกการคำนวณ</button>
    `;
    findAnalyzeRange(nums, minI, maxI);
    return;
  }

  const target = parseNumberInput(document.getElementById("target").value);

  if (isNaN(target)) {
    document.getElementById("results").innerHTML = "<h2>กรุณากรอกผลลัพธ์ที่ต้องการ</h2>";
    isCalculating = false;
    return;
  }
  if (nums.length < 2) {
    document.getElementById("results").innerHTML = "<h2>กรุณาใส่ตัวเลขอย่างน้อย 2 ตัว</h2>";
    isCalculating = false;
    return;
  }

  document.getElementById("results").innerHTML = `
    <h2>กำลังเรียงสับเปลี่ยน...</h2>
    <button id="cancel-calc-btn" onclick="cancelCalculation = true; cancelAllWorkers();">ยกเลิกการคำนวณ</button>
  `;

  if (useFastMode) findFirstSolutionFast(nums, target);
  else if (useSubsetMode) findSubsetSolutionsParallel(nums, target);
  else findAllSolutionsParallel(nums, target);
}

// --- Analyze Mode: aggregate integer outputs in [min..max] ---
function findAnalyzeRange(nums, minTarget, maxTarget){
  const permutations = permute(nums);
  const totalPerms = permutations.length;
  const numWorkers = navigator.hardwareConcurrency || 4;
  calculationCache.clear(); expressionCache.clear();
  activeWorkers.forEach(w=>w.terminate()); activeWorkers=[];

  // Global aggregation: value -> Set(expressions)
  const valueMap = new Map();
  let nextIndex = 0;
  let baseBatchSize = 4; const maxBatchSize = 64;
  let completedPerms = 0; const inProgress = new Map();
  let lastUIUpdate = 0;

  function adaptiveBatchSize(){ if(baseBatchSize < maxBatchSize) baseBatchSize = Math.min(maxBatchSize, baseBatchSize*2); }

  function mergeChunk(entries){
    if(!Array.isArray(entries)) return;
    for(const ent of entries){
      const v = ent.value; const exprs = ent.expressions || [];
      if(!valueMap.has(v)) valueMap.set(v, new Set());
      const set = valueMap.get(v);
      for(const ex of exprs){ set.add(ex); }
    }
  }

  function processedCount(){ let sum=0; inProgress.forEach(v=>{ if(Number.isFinite(v)) sum+=v; }); return completedPerms + sum; }
  function updateUI(force=false){ const now=performance.now(); if(!force && now-lastUIUpdate<120) return; lastUIUpdate=now; const processed = processedCount(); const pct = totalPerms? Math.round((processed/totalPerms)*100):0; const totals = Array.from(valueMap.values()).reduce((a,s)=>a+s.size,0); document.getElementById('results').innerHTML = `
      <h2>กำลังวิเคราะห์ช่วง ${minTarget} ถึง ${maxTarget}... ${pct}% (${processed}/${totalPerms})</h2>
      <p>สะสมสูตรแล้ว: ${totals} แบบ</p>
      <button id=\"cancel-calc-btn\" onclick=\"cancelCalculation = true; cancelAllWorkers();\">ยกเลิกการคำนวณ</button>
    `; }

  function assignBatch(worker){ if(nextIndex>=totalPerms) return; const start=nextIndex; const size=Math.min(baseBatchSize, totalPerms-nextIndex); const end=start+size; nextIndex=end; inProgress.set(worker,0); worker._batchStart=start; worker._batchEnd=end; worker.postMessage({ type:'analyzeRange', permutations, start, end, minTarget, maxTarget, operatorFlags, useIntegerMode: false, MAX_SQRT_DEPTH, MAX_FACT_DEPTH, MAX_LOG_DEPTH, MAX_LN_DEPTH, MAX_FACTORIAL_INPUT, sigmaFormula: SIGMA_FORMULA }); if(nextIndex < totalPerms) adaptiveBatchSize(); }

  for(let w=0; w<numWorkers; w++){
    const worker = new Worker('worker.js'); activeWorkers.push(worker);
  worker.onmessage = (e)=>{
      if(cancelCalculation) return;
      const d=e.data;
      if(d.progress){ if(typeof d.processed==='number' && Number.isFinite(d.processed)){ inProgress.set(worker, Math.min(d.processed, (worker._batchEnd - worker._batchStart))); } updateUI(); return; }
      if(d.analysis){ mergeChunk(d.analysis); }
      const batchSize = (worker._batchEnd - worker._batchStart);
      completedPerms += batchSize; inProgress.delete(worker); updateUI(true);
      if(completedPerms >= totalPerms && inProgress.size===0){
        // finalize
        const elapsed = ((performance.now()-calcStartTime)/1000).toFixed(3);
        renderAnalysisResults(valueMap, minTarget, maxTarget, elapsed);
        isCalculating=false; activeWorkers.forEach(w=>w.terminate()); activeWorkers=[]; return;
      }
      assignBatch(worker);
    };
    worker.onerror = ()=>{ inProgress.delete(worker); completedPerms += (worker._batchEnd - worker._batchStart)||0; updateUI(true); if(completedPerms >= totalPerms && inProgress.size===0){ const elapsed=((performance.now()-calcStartTime)/1000).toFixed(3); renderAnalysisResults(valueMap, minTarget, maxTarget, elapsed); isCalculating=false; activeWorkers.forEach(w=>w.terminate()); activeWorkers=[]; } else { assignBatch(worker); } };
  assignBatch(worker);
  }
}

function renderAnalysisResults(valueMap, minTarget, maxTarget, elapsed){
  _lastAnalysisValueMap = valueMap; _lastAnalysisMin = minTarget; _lastAnalysisMax = maxTarget; _lastAnalysisElapsed = elapsed;
  const baseRows = Array.from(valueMap.entries()).map(([v,set])=>({ value:v, count:set.size, exprs:Array.from(set) }));
  const rows = sortAnalysisRows(baseRows, _analysisSortMode);
  const totalValues = rows.length;
  const totalExprs = rows.reduce((a,r)=>a+r.count,0);
  const head = `<div style="display:flex; align-items:center; justify-content:space-between; gap:8px;">
      <div>
        <h2 style="margin:0;">สรุปผลช่วง ${minTarget} ถึง ${maxTarget}</h2>
        ${renderElapsed(elapsed)}
        <div style="font-size:0.9rem; opacity:0.8;">พบค่า ${totalValues} ค่า • สูตรทั้งหมด ${totalExprs} แบบ</div>
      </div>
      <button id="analysis-sort-btn" class="toggle-btn" style="height:40px; min-width:150px;">เรียง: ${sortModeLabel(_analysisSortMode)}</button>
    </div>`;
  const list = rows.map((r,idx)=>{
    const id = `val-${r.value}-${idx}`;
    const exprItems = r.exprs.map(ex=> `<li>${prettyPrintExpression(ex)}</li>`).join('');
    return `
      <div class="analysis-item" style="border:1px solid var(--card-border); border-radius:10px; padding:8px 10px; margin:8px 0; background:var(--bg-secondary)">
        <div class="analysis-header" data-target="${id}" style="cursor:pointer; display:flex; justify-content:space-between; align-items:center;">
          <div><strong>${r.value}</strong> <span style="opacity:0.75">— ${r.count} สูตร</span></div>
          <div style="opacity:0.7;">กดเพื่อดู/ซ่อน</div>
        </div>
        <ul id="${id}" class="analysis-body" style="display:none; margin:8px 0 4px 16px;">${exprItems}</ul>
      </div>`;
  }).join('');
  document.getElementById('results').innerHTML = head + list;
  // wire toggles
  document.querySelectorAll('.analysis-header').forEach(h=>{
    h.addEventListener('click', ()=>{
      const tid = h.getAttribute('data-target'); const el = document.getElementById(tid); if(!el) return; el.style.display = (el.style.display==='none'||!el.style.display) ? 'block' : 'none';
    });
  });
  // wire sort cycle button
  const sortBtn = document.getElementById('analysis-sort-btn');
  if(sortBtn){
    sortBtn.addEventListener('click', ()=>{
      cycleAnalysisSort();
    });
  }
}

// --- Subset Mode (partial usage) ---
function findSubsetSolutionsParallel(nums, target){
  const n=nums.length; if(n<2){ document.getElementById('results').innerHTML='<h2>ต้องมีอย่างน้อย 2 ตัว</h2>'; isCalculating=false; return; }
  // generate subsets (size >=2, allow full set too so user gets full answers inside this mode)
  const subsets=[]; for(let mask=1; mask < (1<<n); mask++){ let bits=mask; let size=0; while(bits){ size += bits & 1; bits >>=1; } if(size<2) continue; const subset=[]; for(let i=0;i<n;i++){ if(mask & (1<<i)) subset.push(nums[i]); } subsets.push(subset); }
  if(subsets.length===0){ document.getElementById('results').innerHTML='<h2>ไม่มีชุดย่อย</h2>'; isCalculating=false; return; }
  const total=subsets.length; const numWorkers = navigator.hardwareConcurrency || 4; activeWorkers.forEach(w=>w.terminate()); activeWorkers=[]; calcStartTime=performance.now();
  let completed=0; let closest=null; let smallestDiff=Infinity; const EXACT_EPS=1e-12; let lastUI=0; const inProgress=new Map(); let results=[];
  document.getElementById('results').innerHTML=`<h2>โหมดย่อย: เริ่ม...</h2><p>0/${total}</p><button id="cancel-calc-btn" onclick="cancelCalculation=true; cancelAllWorkers();">ยกเลิก</button>`;
  function ui(force=false){ const now=performance.now(); if(!force && now-lastUI<120) return; lastUI=now; const pct=Math.round((completed/total)*100); let cTxt='ยังไม่พบ'; if(closest){ cTxt = (closest.diff<=EXACT_EPS? `${prettyPrintExpression(closest.expression)} = ${formatNumber(closest.result)} (ตรงเป๊ะ)` : `${prettyPrintExpression(closest.expression)} = ${formatNumber(closest.result)} (ห่าง ${formatNumber(closest.diff)})`); }
    document.getElementById('results').innerHTML=`<h2>โหมดย่อย: ${pct}% (${completed}/${total})</h2><p>ดีที่สุด: ${cTxt}</p><button id="cancel-calc-btn" onclick="cancelCalculation=true; cancelAllWorkers();">ยกเลิก</button>`; }
  function finish(){ const elapsed=((performance.now()-calcStartTime)/1000).toFixed(3); if(results.length){ displayResults(results, elapsed); } else if(closest){ const head = closest.diff<=EXACT_EPS ? 'พบคำตอบตรงเป๊ะ (ชุดย่อย)' : 'คำตอบใกล้สุด (ชุดย่อย)'; document.getElementById('results').innerHTML=`<h2>${head}</h2>${renderElapsed(elapsed)}<ul><li>${prettyPrintExpression(closest.expression)} = ${formatNumber(closest.result)}${closest.diff<=EXACT_EPS?'':' (ห่าง '+formatNumber(closest.diff)+')'}</li></ul>`; } else { document.getElementById('results').innerHTML=`<h2>ไม่พบคำตอบ</h2>${renderElapsed(elapsed)}`; } isCalculating=false; activeWorkers.forEach(w=>w.terminate()); activeWorkers=[]; }
  let next=0; function assign(worker){ if(next>=total) return; const start=next; const end=start+1; next=end; inProgress.set(worker,0); worker._start=start; worker._end=end; worker.postMessage({ type:'findAllSubsetsRange', permutations: subsets, start, end, target, operatorFlags, useIntegerMode, MAX_SQRT_DEPTH, MAX_FACT_DEPTH, MAX_LOG_DEPTH, MAX_LN_DEPTH, MAX_FACTORIAL_INPUT, MAX_RESULTS: Infinity, sigmaFormula: SIGMA_FORMULA }); }
  for(let w=0; w<numWorkers; w++){ const worker=new Worker('worker.js'); activeWorkers.push(worker); worker.onmessage=e=>{ if(cancelCalculation) return; const d=e.data; if(d.progress){ if(d.closest && (!closest || d.closest.diff < closest.diff)){ closest=d.closest; } ui(); return; } if(d.results){ for(const r of d.results){ results.push(r); } } if(d.closest && (!closest || d.closest.diff < closest.diff)){ closest=d.closest; } completed += (worker._end - worker._start); inProgress.delete(worker); ui(true); if(completed>=total && inProgress.size===0){ finish(); return; } assign(worker); }; worker.onerror=()=>{ completed += (worker._end - worker._start)||0; inProgress.delete(worker); if(completed>=total && inProgress.size===0) finish(); else assign(worker); }; assign(worker); }
}

function findFirstSolutionFast(nums, target) {
  // explicit wall-clock time budget derived from slider: (value/5) seconds
  const slider = document.getElementById('fast-accuracy-slider');
  const sliderVal = slider ? parseInt(slider.value) : Math.round(fastAccuracy*100);
  const timeBudgetMs = (sliderVal/5)*1000; // 0..20000ms
  const maxSeconds = (timeBudgetMs/1000).toFixed(2);
  const elapsed = () => ((performance.now()-calcStartTime)/1000).toFixed(3);

  const numWorkers = navigator.hardwareConcurrency || 4;
  const workers = [];
  let found = false;
  let globalClosest = null; // accumulate best from all workers
  calculationCache.clear();
  expressionCache.clear();
  const workerPromises = [];

  // initial UI state for fast mode with time budget
  document.getElementById("results").innerHTML = `
    <h2>โหมดเร็ว: กำลังค้นหา (จำกัดเวลา ≤ ${maxSeconds}s)</h2>
    <p>กำลังประมวลผลหลายเธรด...</p>
    <button id="cancel-calc-btn" onclick="cancelCalculation = true; cancelAllWorkers();">ยกเลิกการคำนวณ</button>
  `;

  function updateProgressUI(){
    if(found) return;
    if(!globalClosest){
      document.getElementById("results").innerHTML = `
        <h2>โหมดเร็ว: กำลังค้นหา (≤ ${maxSeconds}s)</h2>
        <p>ยังไม่พบคำตอบใกล้เคียง</p>
        <button id="cancel-calc-btn" onclick="cancelCalculation = true; cancelAllWorkers();">ยกเลิกการคำนวณ</button>`;
      return;
    }
    const diff = globalClosest.diff;
    const EXACT_EPS = 1e-12;
    const status = diff <= EXACT_EPS ? '(ตรงเป๊ะ – เตรียมสรุป)' : `(ห่าง ${formatNumber(diff)})`;
    document.getElementById("results").innerHTML = `
      <h2>โหมดเร็ว: กำลังค้นหา (≤ ${maxSeconds}s)</h2>
      <p>คำตอบใกล้สุด: ${prettyPrintExpression(globalClosest.expression)} = ${formatNumber(globalClosest.result)} ${status}</p>
      <button id="cancel-calc-btn" onclick="cancelCalculation = true; cancelAllWorkers();">ยกเลิกการคำนวณ</button>`;
  }

  for (let i = 0; i < numWorkers; i++) {
    const worker = new Worker('worker.js');
    workers.push(worker);
    activeWorkers.push(worker);
    const promise = new Promise((resolve) => {
      worker.onmessage = function(e) {
        if(found) { resolve(); return; }
        if(e.data.progress){
          // progressive closest candidate update
            if(e.data.closest && (!globalClosest || e.data.closest.diff < globalClosest.diff)) {
              globalClosest = e.data.closest;
              window.closestResultOnCancel = globalClosest; // allow showing best if cancelled
              updateProgressUI();
            }
            return; // do not resolve yet
        }
        if (e.data.found && !found) {
          found = true;
          const { expression, result } = e.data;
          const t = elapsed();
          document.getElementById("results").innerHTML = `<h2>ผลลัพธ์</h2>${renderElapsed(t)}<ul><li>${prettyPrintExpression(expression)} = ${formatNumber(result)}</li></ul>`;
          terminateWorkers(workers);
          activeWorkers = [];
          isCalculating = false;
          resolve();
        } else if (e.data.closest && !found) {
          // final closest from a worker (worker finished its budget)
          if(!globalClosest || e.data.closest.diff < globalClosest.diff){
            globalClosest = e.data.closest;
            window.closestResultOnCancel = globalClosest;
          }
          // if all workers will resolve via Promise.all later
          resolve();
        } else if (e.data.finished) {
          resolve();
        }
      };
      worker.onerror = function(){ resolve(); };
    });
    workerPromises.push(promise);
    worker.postMessage({
      type: 'findFirstFast',
      nums,
      target,
      operatorFlags,
      useIntegerMode,
      MAX_SQRT_DEPTH,
      MAX_FACT_DEPTH,
      MAX_LOG_DEPTH,
      MAX_LN_DEPTH,
      MAX_FACTORIAL_INPUT,
  sigmaFormula: SIGMA_FORMULA,
      speedAccuracy: fastAccuracy, // keep heuristic scaling
      timeBudgetMs, // NEW explicit cap
      allowPartial: useSubsetMode // allow partial expressions only when subset mode active
    });
  }
  // periodic UI refresh while waiting
  const uiInterval = setInterval(()=>{ if(!isCalculating) { clearInterval(uiInterval); return; } updateProgressUI(); }, 250);
  Promise.all(workerPromises).then(()=>{
    clearInterval(uiInterval);
    if(found) return; // already handled
    if(globalClosest){
      const EXACT_EPS = 1e-12;
      const t=elapsed();
      if (Math.abs(globalClosest.diff) <= EXACT_EPS) {
        document.getElementById("results").innerHTML = `
          <h2>ผลลัพธ์</h2>
          ${renderElapsed(t)}
          <ul><li>${prettyPrintExpression(globalClosest.expression)} = ${formatNumber(globalClosest.result)} (ตรงเป๊ะ)</li></ul>`;
      } else {
        document.getElementById("results").innerHTML = `
          <h2>ไม่พบคำตอบที่ตรงเป๊ะ</h2>
          ${renderElapsed(t)}
          <h3>คำตอบที่ใกล้ที่สุด:</h3>
          <ul><li>${prettyPrintExpression(globalClosest.expression)} = ${formatNumber(globalClosest.result)} (ห่าง ${formatNumber(globalClosest.diff)})</li></ul>`;
      }
    } else {
      document.getElementById("results").innerHTML = `<h2>ไม่พบคำตอบภายใน ${maxSeconds}s</h2>${renderElapsed(elapsed())}`;
    }
    terminateWorkers(workers);
    activeWorkers=[];
    isCalculating=false;
  }).catch(()=>{
    clearInterval(uiInterval);
    document.getElementById("results").innerHTML = `<h2>เกิดข้อผิดพลาดในการคำนวณ</h2>`;
    terminateWorkers(workers); activeWorkers=[]; isCalculating=false; });
}

function cancelAllWorkers() {
  activeWorkers.forEach(worker => worker.terminate());
  activeWorkers = [];
  if (isCalculating) {
    isCalculating = false;
    const elapsed = ((performance.now()-calcStartTime)/1000).toFixed(3);
    if (window.closestResultOnCancel) {
      const EXACT_EPS = 1e-12;
      if (Math.abs(window.closestResultOnCancel.diff) <= EXACT_EPS) {
        document.getElementById("results").innerHTML = `
          <h2>การคำนวณถูกยกเลิก</h2>
          ${renderElapsed(elapsed)}
          <h3>พบคำตอบที่ตรงเป๊ะ:</h3>
          <ul><li>${prettyPrintExpression(window.closestResultOnCancel.expression)} = ${formatNumber(window.closestResultOnCancel.result)}</li></ul>`;
      } else {
        document.getElementById("results").innerHTML = `
          <h2>การคำนวณถูกยกเลิก</h2>
          ${renderElapsed(elapsed)}
          <h3>คำตอบที่ใกล้เคียงที่สุด:</h3>
          <ul><li>${prettyPrintExpression(window.closestResultOnCancel.expression)} = ${formatNumber(window.closestResultOnCancel.result)} (ห่างจากเป้าหมาย ${formatNumber(window.closestResultOnCancel.diff)})</li></ul>`;
      }
    } else {
      document.getElementById("results").innerHTML = `<h2>การคำนวณถูกยกเลิก: ไม่พบคำตอบใดๆ</h2>${renderElapsed(elapsed)}`;
    }
  }
}

function findAllSolutionsParallel(nums, target) {
  const permutations = permute(nums);
  const totalPerms = permutations.length;
  if (totalPerms === 0) { document.getElementById("results").innerHTML = "<h2>ไม่พบคำตอบใดๆ</h2>"; isCalculating = false; return; }
  const numWorkers = navigator.hardwareConcurrency || 4;
  calculationCache.clear(); expressionCache.clear();
  activeWorkers.forEach(w=>w.terminate()); activeWorkers=[];

  let results = []; let expressionSet = new Set();
  let closestResult = null; let smallestDiff = Infinity;
  let nextIndex = 0; // next permutation index to assign
  let baseBatchSize = 4; // starting batch size (perms per assignment)
  const maxBatchSize = 64;
  let completedPerms = 0; // fully processed permutations
  const inProgress = new Map(); // worker -> processed inside its current batch
  let workersFinished = 0; // workers that became idle after queue drained
  const EXACT_EPS = 1e-12;
  let lastUIUpdate = 0;

  document.getElementById("results").innerHTML = `
    <h2>กำลังคำนวณ... 0% (0/${totalPerms})</h2>
    <p>ผลลัพธ์ที่ใกล้เคียงที่สุด: ยังไม่พบ</p>
    <button id="cancel-calc-btn" onclick="cancelCalculation = true; cancelAllWorkers();">ยกเลิกการคำนวณ</button>
  `;

  function adaptiveBatchSize(){
    // Simple growth: enlarge when >50% queue remaining processed quickly
    if (baseBatchSize < maxBatchSize) baseBatchSize = Math.min(maxBatchSize, baseBatchSize * 2);
  }

  function aggregateProcessed(){
    // เดิม: รวมค่าทั้งหมดตรงๆ ซึ่งถ้า inProgress มี NaN จะกลายเป็น NaN ทั้งก้อน
    // ปรับ: ข้ามค่าที่ไม่เป็นตัวเลขหรือไม่ finite เพื่อกัน NaN% ใน UI
    let inProgSum = 0; inProgress.forEach(v=> { if(Number.isFinite(v)) inProgSum += v; });
    return completedPerms + inProgSum;
  }

  function updateUI(force=false){
    const now = performance.now(); if(!force && now - lastUIUpdate < 80) return; lastUIUpdate = now;
    const processed = aggregateProcessed();
    const safeProcessed = Number.isFinite(processed)? processed : completedPerms; // กัน NaN ตกค้าง
    const percent = totalPerms>0 ? Math.round((safeProcessed/totalPerms)*100) : 0;
    let closestText = "ยังไม่พบ";
    if (closestResult){
      if (Math.abs(closestResult.diff) <= EXACT_EPS) closestText = `${prettyPrintExpression(closestResult.expression)} = ${formatNumber(closestResult.result)} (ตรงเป๊ะ)`;
      else closestText = `${prettyPrintExpression(closestResult.expression)} = ${formatNumber(closestResult.result)} (ห่างจากเป้าหมาย ${formatNumber(closestResult.diff)})`;
    }
    document.getElementById("results").innerHTML = `
      <h2>กำลังคำนวณ... ${percent}% (${safeProcessed}/${totalPerms})</h2>
      <p>ผลลัพธ์ที่ใกล้เคียงที่สุด: ${closestText}</p>
      <button id="cancel-calc-btn" onclick="cancelCalculation = true; cancelAllWorkers();">ยกเลิกการคำนวณ</button>
    `;
  }

  function finalizeIfDone(){
    if (completedPerms >= totalPerms && inProgress.size===0){
      const elapsed = ((performance.now()-calcStartTime)/1000).toFixed(3);
      // all permutations processed
      if (results.length > 0){ displayResults(results, elapsed); }
      else if (closestResult){
        if (Math.abs(closestResult.diff) <= EXACT_EPS){
          document.getElementById("results").innerHTML = `
            <h2>พบคำตอบที่ตรงเป๊ะ:</h2>
            ${renderElapsed(elapsed)}
            <ul><li>${prettyPrintExpression(closestResult.expression)} = ${formatNumber(closestResult.result)}</li></ul>`;
        } else {
          const diff = Math.abs(closestResult.result - target).toPrecision(8);
          document.getElementById("results").innerHTML = `
            <h2>คำตอบที่ใกล้เคียงที่สุด:</h2>
            ${renderElapsed(elapsed)}
            <ul><li>${prettyPrintExpression(closestResult.expression)} = ${formatNumber(closestResult.result)} (ห่างจากเป้าหมาย ${diff})</li></ul>`;
        }
      } else {
        document.getElementById("results").innerHTML = `<h2>ไม่พบคำตอบที่ใช้ตัวเลขทั้งหมด</h2>${renderElapsed(elapsed)}`;
      }
      activeWorkers.forEach(w=>w.terminate()); activeWorkers=[]; isCalculating=false; return true;
    }
    return false;
  }

  function assignBatch(worker){
    if (cancelCalculation) return; if (nextIndex >= totalPerms){ return; }
  const start = nextIndex; const size = Math.min(baseBatchSize, totalPerms - nextIndex); const end = start + size; nextIndex = end; inProgress.set(worker,0); worker._batchStart=start; worker._batchEnd=end; worker.postMessage({ type:'findAllRange', permutations, start, end, target, nums, operatorFlags, useIntegerMode, MAX_SQRT_DEPTH, MAX_FACT_DEPTH, MAX_LOG_DEPTH, MAX_LN_DEPTH, MAX_FACTORIAL_INPUT, MAX_RESULTS: Infinity, sigmaFormula: SIGMA_FORMULA });
    if (nextIndex < totalPerms) adaptiveBatchSize();
  }

  for(let w=0; w<numWorkers; w++){
    const worker = new Worker('worker.js'); activeWorkers.push(worker);
    worker.onmessage = function(e){ if(cancelCalculation) return; const data=e.data;
      if (data.progress){
        // ป้องกัน NaN: ตั้งค่าเฉพาะเมื่อมีตัวเลข processed ส่งมาจริง
        if (typeof data.processed === 'number' && Number.isFinite(data.processed)) {
          inProgress.set(worker, Math.min(data.processed, (worker._batchEnd - worker._batchStart)));
        }
        if (data.closest && (!closestResult || data.closest.diff < smallestDiff)) { smallestDiff=data.closest.diff; closestResult=data.closest; window.closestResultOnCancel=closestResult; }
        updateUI();
        return;
      }
  if (data.results){
        data.results.forEach(res=>{ if(!expressionSet.has(res.expression)){ expressionSet.add(res.expression); results.push(res);} });
      }
      if (data.closest && (!closestResult || data.closest.diff < smallestDiff)) { smallestDiff=data.closest.diff; closestResult=data.closest; window.closestResultOnCancel=closestResult; }
      // batch finished
      const batchSize = (worker._batchEnd - worker._batchStart);
      completedPerms += batchSize; inProgress.delete(worker); updateUI(true);
      if (finalizeIfDone()) return;
      assignBatch(worker);
      if (nextIndex >= totalPerms && !inProgress.has(worker)){ // no more work assigned to this worker
        workersFinished++;
      }
    };
    worker.onerror = function(){ inProgress.delete(worker); completedPerms += (worker._batchEnd - worker._batchStart)||0; updateUI(true); if(!finalizeIfDone()) assignBatch(worker); };
    assignBatch(worker);
  }
}

function permute(arr) {
  const seen = new Set();
  const permutations = [];
  const c = new Array(arr.length).fill(0);
  let i = 1;
  const initial = arr.slice();
  const key = initial.join(",");
  seen.add(key);
  permutations.push(initial);
  while (i < arr.length) {
    if (c[i] < i) {
      const swapIndex = i % 2 ? c[i] : 0;
      [arr[swapIndex], arr[i]] = [arr[i], arr[swapIndex]];
      const key = arr.join(",");
      if (!seen.has(key)) {
        seen.add(key);
        permutations.push(arr.slice());
      }
      c[i]++;
      i = 1;
    } else {
      c[i] = 0;
      i++;
    }
  }
  return permutations;
}

function terminateWorkers(workers) {
  workers.forEach(worker => worker.terminate());
}

function usesAllNumbers(ast, originalNums) {
  const numbers = [];
  function extractNumbers(node) {
    if (node.type === "num") numbers.push(node.value);
    if (node.left) extractNumbers(node.left);
    if (node.right) extractNumbers(node.right);
  }
  extractNumbers(ast);
  if (numbers.length !== originalNums.length) return false;
  const sortedUsed = [...numbers].sort((a, b) => a - b);
  const sortedOriginal = [...originalNums].sort((a, b) => a - b);
  const EPS = 1e-9;
  for (let i = 0; i < sortedUsed.length; i++) {
    if (Math.abs(sortedUsed[i] - sortedOriginal[i]) > EPS) return false;
  }
  return true;
}

function respectsLockOrder(ast, originalNums, lockedIndices) {
  const numberPositions = [];
  function extractPositions(node, position = []) {
    if (node.type === "num") numberPositions.push({ value: node.value, position: [...position] });
    if (node.left) extractPositions(node.left, [...position, 'left']);
    if (node.right) extractPositions(node.right, [...position, 'right']);
  }
  extractPositions(ast);
  const originalPositions = new Map();
  originalNums.forEach((num, index) => originalPositions.set(index, num));
  for (const lockedIndex of lockedIndices) {
    const lockedNum = originalNums[lockedIndex];
    const lockedPosInAST = numberPositions.find(np => np.value === lockedNum);
    if (!lockedPosInAST) return false;
    const allPositions = numberPositions.map(np => np.position.length);
    const maxDepth = Math.max(...allPositions);
    const lockedDepth = lockedPosInAST.position.length;
    if (lockedIndex === originalNums.length - 1) {
      if (lockedDepth !== maxDepth || numberPositions.filter(np => np.position.length === maxDepth).length > 1) return false;
    } else if (lockedIndex === 0) {
      if (lockedDepth !== 0) return false;
    } else {
      const beforeLocked = originalNums.slice(0, lockedIndex);
      const afterLocked = originalNums.slice(lockedIndex + 1);
      const beforeCount = numberPositions.filter(np => beforeLocked.includes(np.value) && np.position.length < lockedDepth).length;
      const afterCount = numberPositions.filter(np => afterLocked.includes(np.value) && np.position.length > lockedDepth).length;
      if (beforeCount !== beforeLocked.length || afterCount !== afterLocked.length) return false;
    }
  }
  return true;
}

function updateProgress(processed, total, target, results, closestResult) {
  const percent = Math.round((processed / total) * 100);
  let closestText = "ยังไม่พบ";
  const EXACT_EPS = 1e-12;
  if (closestResult) {
    if (Math.abs(closestResult.diff) <= EXACT_EPS) {
      closestText = `${prettyPrintExpression(closestResult.expression)} = ${formatNumber(closestResult.result)} (ตรงเป๊ะ)`;
    } else {
      closestText = `${prettyPrintExpression(closestResult.expression)} = ${formatNumber(closestResult.result)} (ห่างจากเป้าหมาย ${formatNumber(closestResult.diff)})`;
    }
  }
  document.getElementById("results").innerHTML = `
    <h2>กำลังคำนวณ... ${percent}% (${processed}/${total})</h2>
    <p>ผลลัพธ์ที่ใกล้เคียงที่สุด: ${closestText}</p>
    <button id="cancel-calc-btn" onclick="cancelCalculation = true; cancelAllWorkers();">ยกเลิกการคำนวณ</button>
  `;
}

function prettyPrintExpression(expr) {
  let s = expr
    .replace(/\( *([^\(\)]+) *\)!/g, '$1!')
    .replace(/√\(([^(\)]+)\)/g, '√$1');
  s = s.replace(/\(([^(\)]+)\s\^\s([^\(\)]+)\)/g, '$1^$2');
  s = s.replace(/\*/g, '×').replace(/\//g, '÷').replace(/%/g, ' mod ');
  // keep || as is, or could replace with ⧺ later
  s = s.replace(/\(([0-9]+)\)/g, '$1');
  // Replace numeric constants with math symbols
  s = s.replace(/2\.718281828459045/g, 'e');
  s = s.replace(/3\.141592653589793/g, 'π');
  // Remove trivial parentheses around constants
  s = s.replace(/\((π|e)\)/g, '$1');
  while (
    s.startsWith('(') &&
    s.endsWith(')') &&
    (() => {
      let depth = 0;
      for (let i = 0; i < s.length; ++i) {
        if (s[i] === '(') depth++;
        if (s[i] === ')') depth--;
        if (depth === 0 && i < s.length - 1) return false;
      }
      return depth === 0;
    })()
  ) {
    s = s.slice(1, -1);
  }
  s = s.replace(/\s+/g, ' ').replace(/\( /g, '(').replace(/ \)/g, ')');
  return s;
}

// --- Dynamic Results Filtering (UI + Logic) ---
let _lastResults = [];
let _lastElapsed = '0.000';
let _currentFilterQuery = '';
let _filterVisible = false; // default hidden
// New: operator chip states (any | include | exclude)
const _allFilterOps = ['+','-','*','/','%','^','√','!','∑','||','log','ln'];
let _filterOpStates = Object.fromEntries(_allFilterOps.map(op=>[op,'any']));

// --- Analyze Mode sorting state ---
let _analysisSortMode = 'count-desc'; // 'count-desc' | 'count-asc' | 'value-desc' | 'value-asc'
function sortAnalysisRows(rows, mode){
  const arr = rows.slice();
  switch(mode){
    case 'count-asc':
      arr.sort((a,b)=> (a.count - b.count) || (a.value - b.value));
      break;
    case 'value-desc':
      arr.sort((a,b)=> (b.value - a.value) || (b.count - a.count));
      break;
    case 'value-asc':
      arr.sort((a,b)=> (a.value - b.value) || (b.count - a.count));
      break;
    case 'count-desc':
    default:
      arr.sort((a,b)=> (b.count - a.count) || (a.value - b.value));
      break;
  }
  return arr;
}

// Persist last analysis data to enable re-rendering when cycling sort
let _lastAnalysisValueMap = null;
let _lastAnalysisMin = 0;
let _lastAnalysisMax = 0;
let _lastAnalysisElapsed = '0.000';
function sortModeLabel(mode){
  switch(mode){
    case 'count-asc': return 'สูตรน้อย→มาก';
    case 'value-desc': return 'ตัวเลขมาก→น้อย';
    case 'value-asc': return 'ตัวเลขน้อย→มาก';
    case 'count-desc':
    default: return 'สูตรมาก→น้อย';
  }
}
function cycleAnalysisSort(){
  const modes = ['count-desc','count-asc','value-desc','value-asc'];
  let idx = modes.indexOf(_analysisSortMode);
  if(idx < 0) idx = 0;
  _analysisSortMode = modes[(idx+1) % modes.length];
  if(_lastAnalysisValueMap){
    renderAnalysisResults(_lastAnalysisValueMap, _lastAnalysisMin, _lastAnalysisMax, _lastAnalysisElapsed);
  }
}

function normalizeOpToken(tok){
  const t = tok.toLowerCase();
  if (t === '×' || t === '*') return '*';
  if (t === '÷' || t === '/') return '/';
  if (t === 'mod' || t === '%') return '%';
  if (t === '^' || t === 'pow' || t === 'power') return '^';
  if (t === 'sqrt' || t === '√') return '√';
  if (t === '!' || t === 'fact' || t === 'factorial') return '!';
  if (t === 'sum' || t === 'sigma' || t === '∑') return '∑';
  if (t === 'concat' || t === '||') return '||';
  if (t === 'log') return 'log';
  if (t === 'ln') return 'ln';
  if (t === '+') return '+';
  if (t === '-' || t === 'minus' || t === 'sub') return '-';
  if (t === 'add' || t === 'plus') return '+';
  return null;
}

function parseFilterQuery(q){
  const includeOps = new Set();
  const excludeOps = new Set();
  const includeTerms = new Set();
  const excludeTerms = new Set();
  if(!q) return { includeOps, excludeOps, includeTerms, excludeTerms };
  const tokens = q.trim().split(/\s+/).filter(Boolean);
  for(const raw of tokens){
    if(raw.startsWith('-') && raw.length>1){
      const body = raw.slice(1);
      const op = normalizeOpToken(body);
      if(op) excludeOps.add(op); else excludeTerms.add(body.toLowerCase());
    } else {
      const op = normalizeOpToken(raw);
      if(op) includeOps.add(op); else includeTerms.add(raw.toLowerCase());
    }
  }
  // resolve conflicts: includes win over excludes
  for(const op of includeOps){ excludeOps.delete(op); }
  return { includeOps, excludeOps, includeTerms, excludeTerms };
}

function exprHasOperator(expr, op){
  // check raw expression string, not pretty, to avoid symbol replacement issues
  switch(op){
    case '||': return expr.includes('||');
    case 'log': return expr.includes('log(');
    case 'ln': return expr.includes('ln(');
    case '√': return expr.includes('√');
    case '∑': return expr.includes('∑');
    case '!': return expr.includes('!');
    case '^': return expr.includes('^');
    case '%': return expr.includes('%');
    case '*': return expr.includes('*');
    case '/': return expr.includes('/');
    case '+': return expr.includes('+');
    case '-': return expr.includes('-');
    default: return false;
  }
}

function filterResults(results, query){
  const { includeOps, excludeOps, includeTerms, excludeTerms } = parseFilterQuery(query);
  return results.filter(r => {
    const expr = r.expression || '';
    const pretty = prettyPrintExpression(expr).toLowerCase();
    // includes: all must match
    for(const op of includeOps){ if(!exprHasOperator(expr, op)) return false; }
    for(const term of includeTerms){ if(!pretty.includes(term)) return false; }
    // excludes: none must match
    for(const op of excludeOps){ if(exprHasOperator(expr, op)) return false; }
    for(const term of excludeTerms){ if(pretty.includes(term)) return false; }
    return true;
  });
}

function buildResultsContainer(total, elapsed){
  // Build container with chip-based filter controls
  document.getElementById("results").innerHTML = `
    <div style="display:flex; align-items:center; justify-content:space-between; gap:8px;">
      <h2 style="margin:0;">ผลลัพธ์ (<span id=\"filtered-count\">0</span>/${total} รายการ)</h2>
      <button id=\"toggle-filters\" class=\"toggle-btn\" style=\"padding:8px 12px;\">${_filterVisible ? 'ซ่อนตัวกรอง' : 'แสดงตัวกรอง'}</button>
    </div>
    ${renderElapsed(elapsed)}
    <div id="results-filter" class="results-filter" style="margin:8px 0 10px; display:${_filterVisible ? 'block' : 'none'};">
      <div style="display:flex; flex-wrap:wrap; gap:8px; align-items:center;">
        ${_allFilterOps.map(op=>{
          const label = op==='*'?'×': op==='/'?'÷': op==='%'?'mod': op==='||'?'concat': op;
          return `<button class="chip" data-op="${op}" data-state="${_filterOpStates[op]}" 
            style="padding:10px 12px; border-radius:14px; border:1px solid var(--card-border); background: var(--bg-secondary); color: var(--text-primary); cursor:pointer; font-size:0.95rem; min-width:88px; height:40px; display:inline-flex; align-items:center; justify-content:center;">${label}</button>`;
        }).join('')}
      </div>
      <div style="font-size:0.8rem; opacity:0.75; margin-top:4px;">
        แตะปุ่มเพื่อวนสถานะ: ไม่กำหนด → ต้องมี → ไม่เอา
      </div>
    </div>
    <ul id="results-list"></ul>
  `;
  // wire toggle
  const toggleBtn = document.getElementById('toggle-filters');
  const filterBox = document.getElementById('results-filter');
  if(toggleBtn && filterBox){
    toggleBtn.addEventListener('click', ()=>{
      _filterVisible = !_filterVisible;
      filterBox.style.display = _filterVisible ? 'block' : 'none';
      toggleBtn.textContent = _filterVisible ? 'ซ่อนตัวกรอง' : 'แสดงตัวกรอง';
    });
  }
  // apply chip styles and events
  const chips = Array.from(document.querySelectorAll('#results-filter .chip'));
  chips.forEach(btn=>{
    const op = btn.dataset.op;
    // style based on state
    function applyStyle(){
      const st = _filterOpStates[op];
      if(st==='include'){
        btn.style.background = 'var(--bg-secondary)';
        btn.style.borderColor = 'var(--accent-green)';
        btn.style.color = 'var(--text-primary)';
      } else if(st==='exclude'){
        btn.style.background = 'var(--bg-secondary)';
        btn.style.borderColor = 'var(--accent-red)';
        btn.style.color = 'var(--text-primary)';
      } else {
        btn.style.background = 'var(--bg-secondary)';
        btn.style.borderColor = 'var(--card-border)';
        btn.style.color = 'var(--text-primary)';
      }
      btn.dataset.state = st;
    }
    applyStyle();
    btn.addEventListener('click', ()=>{
      const cur = _filterOpStates[op];
      const next = cur==='any' ? 'include' : cur==='include' ? 'exclude' : 'any';
      _filterOpStates[op] = next;
      applyStyle();
      updateFilteredResultsList();
    });
  });
}

function updateFilteredResultsList(){
  // build include/exclude sets from chip states
  const includeOps = new Set();
  const excludeOps = new Set();
  for(const op of _allFilterOps){
    const st = _filterOpStates[op];
    if(st==='include') includeOps.add(op);
    else if(st==='exclude') excludeOps.add(op);
  }
  
  const filtered = _lastResults.filter(r => {
    const expr = r.expression || '';
    
    // Apply operator filtering only (target filtering already done in displayResults)
    for(const op of includeOps){ if(!exprHasOperator(expr, op)) return false; }
    for(const op of excludeOps){ if(exprHasOperator(expr, op)) return false; }
    
    return true;
  });
  
  const listEl = document.getElementById('results-list');
  const countEl = document.getElementById('filtered-count');
  if(countEl) countEl.textContent = String(filtered.length);
  if(listEl){
    listEl.innerHTML = filtered.map(res => {
      return `<li>${prettyPrintExpression(res.expression)} = ${formatNumber(res.result)}</li>`;
    }).join('');
  }
}

function displayResults(results, elapsedOverride) {
  const elapsed = elapsedOverride || ((performance.now()-calcStartTime)/1000).toFixed(3);
  if (results.length > 0) {
    // Filter results to ensure they actually match the target with tighter tolerance
    const target = parseNumberInput(document.getElementById("target").value);
    if (Number.isFinite(target)) {
      results = results.filter(res => {
        // Force recalculation to verify accuracy instead of trusting stored results
        const ast = parseSerializedExpression(res.expression);
        if (ast) {
          const recalculated = evaluateAST(ast);
          return validateResultExact(recalculated, target);
        }
        return false;
      });
    }
    
    if(useCleanMode){
      function computeCleanScore(expr){
        const protectedExpr = expr.replace(/\|\|/g,'§').replace(/log(?=\()/g,'Ł').replace(/ln(?=\()/g,'ŀ');
        const ops = protectedExpr.match(/[+\-*\/^%√!§∑Łŀ]/g) || [];
        const opCount = ops.length;
        const parenCount = (expr.match(/\(/g)||[]).length;
        const weightMap = { '+':1, '-':1, '*':2, '/':2, '%':3, '§':5, '^':3, '√':4, '!':4, '∑':5, 'Ł':4, 'ŀ':4 };
  let sumWeight=0;
  ops.forEach(o=>{ const w=weightMap[o]||9; sumWeight+=w; });
  return { sumWeight, opCount, parenCount, length: expr.length };
      }
      function betterScore(a,b){
        if(a.sumWeight!==b.sumWeight) return a.sumWeight - b.sumWeight;
        if(a.opCount!==b.opCount) return a.opCount - b.opCount;
        if(a.parenCount!==b.parenCount) return a.parenCount - b.parenCount;
        return a.length - b.length;
      }
      let best = null; let bestScore=null;
      for(const r of results){
        const sc = computeCleanScore(r.expression);
        if(!best || betterScore(sc,bestScore)<0){ best=r; bestScore=sc; }
      }
      if(best){
        document.getElementById("results").innerHTML = `
          <h2>ผลลัพธ์ที่คลีนที่สุด (จาก ${results.length} แบบ)</h2>
          ${renderElapsed(elapsed)}
          <ul><li>${prettyPrintExpression(best.expression)} = ${formatNumber(best.result)}</li></ul>`;
        return;
      }
    }
  // Save and render with dynamic filtering UI
  _lastResults = results.slice();
  _lastElapsed = elapsed;
  
  // Pre-filter _lastResults to remove invalid ones permanently
  const targetForFilter = parseNumberInput(document.getElementById("target").value);
  if (Number.isFinite(targetForFilter)) {
    _lastResults = _lastResults.filter(res => {
      // Force recalculation to verify accuracy instead of trusting stored results
      const ast = parseSerializedExpression(res.expression);
      if (ast) {
        const recalculated = evaluateAST(ast);
        return validateResultExact(recalculated, targetForFilter);
      }
      return false;
    });
  }
  
  buildResultsContainer(_lastResults.length, elapsed);
  updateFilteredResultsList();
  // Enhance with path buttons after initial render
  setTimeout(enhanceResultsWithPathButtons, 0);
  } else if (window.closestResultOnCancel) {
  const target = parseNumberInput(document.getElementById("target").value);
    const EXACT_EPS = 1e-12;
    const diffRaw = Math.abs(window.closestResultOnCancel.result - target);
    if (diffRaw <= EXACT_EPS) {
      document.getElementById("results").innerHTML = `
        <h2>พบคำตอบที่ตรงเป๊ะ:</h2>
        ${renderElapsed(elapsed)}
        <ul><li>${prettyPrintExpression(window.closestResultOnCancel.expression)} = ${formatNumber(window.closestResultOnCancel.result)}</li></ul>`;
    } else {
      const diff = diffRaw.toPrecision(8);
      document.getElementById("results").innerHTML = `
        <h2>คำตอบที่ใกล้เคียงที่สุด:</h2>
        ${renderElapsed(elapsed)}
        <ul><li>${prettyPrintExpression(window.closestResultOnCancel.expression)} = ${formatNumber(window.closestResultOnCancel.result)} (ห่างจากเป้าหมาย ${diff})</li></ul>`;
    }
  } else {
    document.getElementById("results").innerHTML = `<h2>ไม่พบคำตอบที่ใช้ตัวเลขทั้งหมด</h2>${renderElapsed(elapsed)}`;
  }
}

// ================= Calculation Path Visualization =================
// Parse serialized expression (worker serializeAST format) -> AST
function parseSerializedExpression(expr){
  try {
    const tokens = tokenizeExpr(expr);
    let pos = 0;
    function peek(){ return tokens[pos]; }
    function consume(tok){ if(tok && tokens[pos] !== tok) throw new Error('expected '+tok+' got '+tokens[pos]); return tokens[pos++]; }
    function isUnary(t){ return t==='√' || t==='log' || t==='ln'; }
    function parsePrimary(){
      let t = peek();
      if(t==null) throw new Error('unexpected end');
      if(isUnary(t)){
        const op = consume(t);
        // operand always serialized with parentheses root or expression directly after for our serializer
        const child = parsePrimary();
        return { type:'op', operator: op==='√'? '√': op, left:null, right: child };
      }
      if(t==='('){
        consume('(');
        let first = parsePrimary();
        const binaryOps = new Set(['+','-','*','/','%','^','||','∑']);
        const maybe = peek();
        if(maybe && binaryOps.has(maybe)){
          const op = consume(maybe);
          const second = parsePrimary();
          consume(')');
          let node = { type:'op', operator: op, left:first, right:second };
          while(peek()==='!'){ consume('!'); node = { type:'op', operator:'!', left:null, right: node }; }
          return node;
        } else {
          consume(')');
          let node = first;
          while(peek()==='!'){ consume('!'); node = { type:'op', operator:'!', left:null, right: node }; }
          return node;
        }
      }
      if(t==='!') throw new Error('dangling !');
      // number
      if(/^[0-9.]+$/.test(t)){
        consume(t);
        let val = parseFloat(t);
        return { type:'num', value: val };
      }
      throw new Error('unexpected token '+t);
    }
    const ast = parsePrimary();
    if(pos !== tokens.length) throw new Error('extra tokens');
    return ast;
  } catch(err){
    console.warn('parseSerializedExpression error', err, expr);
    return null;
  }
}

function tokenizeExpr(s){
  const tokens=[]; let i=0; while(i<s.length){ const ch=s[i];
    if(/\s/.test(ch)){ i++; continue; }
  if(ch==='×'){ tokens.push('*'); i++; continue; }
  if(ch==='÷'){ tokens.push('/'); i++; continue; }
    if(ch==='('||ch===')'||ch==='!'||ch==='√'){ tokens.push(ch); i++; continue; }
    if(ch==='|' && s[i+1]==='|'){ tokens.push('||'); i+=2; continue; }
    if(ch==='∑'){ tokens.push('∑'); i++; continue; }
    if(ch==='+'||ch==='-'||ch==='*'||ch==='/'||ch==='%'||ch==='^'){ tokens.push(ch); i++; continue; }
    if(ch==='l'){ // log or ln
      if(s.slice(i,i+3)==='log'){ tokens.push('log'); i+=3; continue; }
      if(s.slice(i,i+2)==='ln'){ tokens.push('ln'); i+=2; continue; }
    }
    if(/[0-9.]/.test(ch)){
      let j=i; while(j<s.length && /[0-9.]/.test(s[j])) j++;
      tokens.push(s.slice(i,j)); i=j; continue; }
    // ignore surrounding parentheses added by prettyPrint cleanup maybe
    console.warn('unknown char in tokenize', ch, 'in', s);
    i++;
  }
  return tokens;
}

function computeStepsAndValues(ast){
  const steps=[];
  function evalNode(n){
    if(!n) return NaN;
    if(n.type==='num') return n.value;
    const op = n.operator;
    if(op==='!'||op==='√'||op==='log'||op==='ln'){
      const valChild = evalNode(n.right);
      let result;
      switch(op){
        case '!': result = factorial(valChild); break;
        case '√': result = valChild<0? NaN : Math.sqrt(valChild); break;
        case 'log': result = valChild>0? Math.log10(valChild): NaN; break;
        case 'ln': result = valChild>0? Math.log(valChild): NaN; break;
      }
      n.value = result;
      steps.push({ type:'unary', op, a: valChild, r: result });
      return result;
    }
    // binary
    const lv = evalNode(n.left);
    const rv = evalNode(n.right);
    let r;
    switch(op){
      case '+': r=lv+rv; break;
      case '-': r=lv-rv; break;
      case '*': r=lv*rv; break;
      case '/': r= Math.abs(rv)<1e-12? NaN: lv/rv; break;
      case '%': r= Math.abs(rv)<1e-12? NaN: lv - rv*Math.floor(lv/rv); break;
      case '^': r= (lv===0 && rv<=0)? NaN: Math.pow(lv,rv); break;
      case '||': r = (Number.isInteger(lv)&&Number.isInteger(rv) && lv>=0 && rv>=0)? parseFloat(String(Math.trunc(lv))+String(Math.trunc(rv))) : NaN; break;
      case '∑': {
        if(Number.isInteger(lv) && Number.isInteger(rv) && lv<=rv){ const n=rv-lv+1; r=(lv+rv)*n/2; } else r=NaN; break; }
      default: r=NaN;
    }
    n.value = r;
    steps.push({ type:'binary', op, a: lv, b: rv, r });
    return r;
  }
  const finalVal = evalNode(ast);
  
  // Validate path result matches expected target for consistency
  const targetInput = document.getElementById("target");
  if (targetInput) {
    const target = parseNumberInput(targetInput.value);
    if (Number.isFinite(target) && !validateResultExact(finalVal, target)) {
      console.warn('Path calculation mismatch:', finalVal, 'vs target:', target);
      // Still return steps but mark as inconsistent
      return { steps, final: finalVal, inconsistent: true };
    }
  }
  
  return { steps, final: finalVal };
}

function displayOperator(op){
  switch(op){
    case '*': return '×';
    case '/': return '÷';
    case '%': return 'mod';
    default: return op;
  }
}

function buildStepsHTML(steps){
  let idx=1; return '<ol class="calc-steps-list">'+ steps.map(st=>{
    if(st.type==='binary') return `<li>${idx++}) ${formatNumber(st.a)} ${displayOperator(st.op)} ${formatNumber(st.b)} = ${formatNumber(st.r)}</li>`;
    else return `<li>${idx++}) ${displayOperator(st.op)}(${formatNumber(st.a)}) = ${formatNumber(st.r)}</li>`;
  }).join('') + '</ol>';
}

function buildAsciiTree(ast){
  return '';// legacy placeholder
}

function buildSvgTree(ast){
  // Compact recursive layout: width derives from subtree widths so skewed trees stay narrow.
  const H_GAP = 48; // horizontal gap between sibling subtrees
  const V_GAP = 70; // vertical distance per depth
  const NODE_W = 60, NODE_H = 30, PAD = 20;
  const placed = []; // { node, depth, x }
  function layout(n, depth, offsetX){
    if(!n) return { width: NODE_W };
    if(n.type==='num'){
      placed.push({ node:n, depth, x: offsetX + NODE_W/2 });
      return { width: NODE_W };
    }
    // Unary operators: width equals child's width (no extra horizontal expansion)
    if(n.operator==='!'||n.operator==='√'||n.operator==='log'||n.operator==='ln'){
      const childInfo = layout(n.right, depth+1, offsetX);
      placed.push({ node:n, depth, x: offsetX + childInfo.width/2 });
      return { width: childInfo.width };
    }
    // Binary operators: place left subtree then right subtree with gap
    const leftInfo = layout(n.left, depth+1, offsetX);
    const rightInfo = layout(n.right, depth+1, offsetX + leftInfo.width + H_GAP);
    const totalW = leftInfo.width + H_GAP + rightInfo.width;
    placed.push({ node:n, depth, x: offsetX + totalW/2 });
    return { width: totalW };
  }
  const rootInfo = layout(ast, 0, 0);
  const maxDepth = placed.reduce((m,p)=> Math.max(m,p.depth), 0);
  const svgWidth = Math.max(rootInfo.width + PAD*2, NODE_W + PAD*2);
  const svgHeight = (maxDepth+1)*V_GAP + PAD*2;
  const map = new Map(placed.map(p=>[p.node,p]));
  const edges = [];
  placed.forEach(p=>{
    const n=p.node; if(n.type!=='op') return;
    if(n.operator==='!'||n.operator==='√'||n.operator==='log'||n.operator==='ln'){
      const c=map.get(n.right); if(c) edges.push({a:p,b:c});
    } else {
      const l=map.get(n.left); const r=map.get(n.right); if(l) edges.push({a:p,b:l}); if(r) edges.push({a:p,b:r});
    }
  });
  function label(n){ return n.type==='num' ? formatNumber(n.value) : displayOperator(n.operator); }
  function subLabel(n){ if(n.type==='num') return ''; return formatNumber(n.value); }
  let svg = `<svg class="calc-tree-svg" width="${svgWidth}" height="${svgHeight}" viewBox="0 0 ${svgWidth} ${svgHeight}" xmlns="http://www.w3.org/2000/svg">`;
  svg += `<g stroke="var(--text-secondary)" stroke-width="1.2" stroke-linecap="round">`;
  edges.forEach(e=>{ svg += `<line x1="${PAD + e.a.x}" y1="${PAD + e.a.depth*V_GAP + NODE_H/2}" x2="${PAD + e.b.x}" y2="${PAD + e.b.depth*V_GAP - NODE_H/2}" />`; });
  svg += '</g>';
  placed.forEach(p=>{
    const cx = PAD + p.x; const cy = PAD + p.depth*V_GAP; const gx = cx - NODE_W/2; const gy = cy - NODE_H/2;
    svg += `<g class="tree-node" transform="translate(${gx},${gy})">`;
    svg += `<rect rx="8" ry="8" width="${NODE_W}" height="${NODE_H}" fill="var(--bg-tertiary)" stroke="var(--card-border)" />`;
    svg += `<text x="${NODE_W/2}" y="${NODE_H/2 - (p.node.type==='op'?2:0)}" text-anchor="middle" dominant-baseline="middle" font-size="13" fill="var(--text-primary)" font-family="inherit">${label(p.node)}</text>`;
    const sub = subLabel(p.node); if(sub) svg += `<text x="${NODE_W/2}" y="${NODE_H-5}" text-anchor="middle" font-size="9" fill="var(--text-secondary)" font-family="inherit">${sub}</text>`;
    svg += '</g>';
  });
  svg += '</svg>';
  return svg;
}

function enhanceResultsWithPathButtons(){
  // Target result lists (#results-list or any results > ul under #results not analysis)
  const lists = Array.from(document.querySelectorAll('#results-list, #results > ul'));
  lists.forEach(ul=>{
    if(ul && ul.classList.contains('analysis-body')) return;
    Array.from(ul.querySelectorAll('li')).forEach(li=>{
      if(li.dataset.hasPath==='1') return;
      const textSpan = li.innerHTML;
      // We need to locate the raw expression from _lastResults by matching pretty expression start
      const match = textSpan.split('=')[0].trim();
      // Find corresponding raw expression
      let raw = null; if(Array.isArray(_lastResults)){
        for(const r of _lastResults){ const pretty = prettyPrintExpression(r.expression); if(textSpan.includes(pretty+' =') || match===pretty){ raw = r.expression; break; } }
      }
      if(!raw) return; // skip if not found (analysis or other lists)
      const btn = document.createElement('button');
      btn.type='button'; btn.className='path-btn'; btn.textContent='ดูเส้นทาง'; btn.style.marginLeft='8px'; btn.style.padding='4px 10px'; btn.style.fontSize='0.75rem'; btn.style.background='var(--accent-purple)'; btn.style.boxShadow='0 2px 6px rgba(0,0,0,0.25)';
      const container = document.createElement('div'); container.className='calc-path hidden'; container.style.display='none';
      li.appendChild(btn); li.appendChild(container); li.dataset.rawExpression = raw; li.dataset.hasPath='1';
    });
  });
}

// Global click handler for path toggle
document.addEventListener('click', (e)=>{
  const btn = e.target.closest('.path-btn'); if(!btn) return;
  const li = btn.closest('li'); if(!li) return; const box = li.querySelector('.calc-path'); if(!box) return;
  if(box.dataset.loaded!=='1'){
    const raw = li.dataset.rawExpression; const ast = parseSerializedExpression(raw);
    if(!ast){ box.innerHTML='<div style="opacity:0.7;">ไม่สามารถแสดงเส้นทาง</div>'; box.style.display='block'; btn.textContent='ซ่อนเส้นทาง'; box.dataset.loaded='1'; return; }
    
    const pathData = computeStepsAndValues(ast);
    const { steps, inconsistent } = pathData;
    const stepsHTML = buildStepsHTML(steps);
    const svg = buildSvgTree(ast);
    
    let warningHTML = '';
    if (inconsistent) {
      warningHTML = '<div style="color: var(--accent-red); font-size: 0.9rem; margin-bottom: 8px; padding: 6px; background: var(--bg-tertiary); border-radius: 6px;">⚠️ การคำนวณซ้ำไม่ตรงกับเป้าหมาย - อาจมีความคลาดเคลื่อนเล็กน้อย</div>';
    }
    
    box.innerHTML = `<div class="calc-path-content">${warningHTML}<div class="calc-steps"><div class="calc-path-title">การคำนวณทีละขั้น</div>${stepsHTML}</div><div class="calc-tree"><div class="calc-path-title" style="margin-top:6px;">แผนภูมิต้นไม้</div><div class="calc-tree-wrapper">${svg}</div></div></div>`;
    box.dataset.loaded='1';
  }
  const showing = box.style.display !== 'none';
  if(showing){ box.style.display='none'; btn.textContent='ดูเส้นทาง'; }
  else { box.style.display='block'; btn.textContent='ซ่อนเส้นทาง'; }
});

// Observe #results for dynamic mode updates (fast / clean) and attach buttons automatically
const __pathObserverTarget = document.getElementById('results');
if(__pathObserverTarget){
  const mo = new MutationObserver(()=>{ enhanceResultsWithPathButtons(); });
  mo.observe(__pathObserverTarget, { childList:true, subtree:true });
}

// NEW helper to render elapsed time snippet at top
function renderElapsed(seconds){
  return `<div class="elapsed-time" style="margin:4px 0 10px; font-size:0.85rem; opacity:0.85;">เวลาใช้ไป: ${seconds} วินาที</div>`;
}

// Initialize
addNumber();
// Ensure initial input supports decimals
const firstNum = document.querySelector('.num');
if (firstNum) firstNum.step = 'any';


// Initialize WASM status
initializeWASM();

// Set initial button states
document.getElementById("toggleAddBtn").textContent = "ปิดการใช้ +";
document.getElementById("toggleSubBtn").textContent = "ปิดการใช้ -";
document.getElementById("toggleMulBtn").textContent = "ปิดการใช้ ×";
document.getElementById("toggleDivBtn").textContent = "ปิดการใช้ ÷";

// Replace with simple non-drag navigation for stability on touch devices
function initNavSwitch(){
  const buttons = document.querySelectorAll('.nav-glass-switch .nav-btn');
  buttons.forEach(btn=>{
    // Ensure single activation logic
    btn.addEventListener('click', ()=> showPage(btn.dataset.target, btn));
    // Explicit touchstart for iOS (prevent 300ms delay / ghost double-trigger)
    btn.addEventListener('touchstart', (e)=>{ e.preventDefault(); showPage(btn.dataset.target, btn); }, {passive:false});
  });
  // Initial blob positioning
  requestAnimationFrame(updateNavBlob);
}
window.addEventListener('load', initNavSwitch);

// Improved drag logic (re-instated with simpler reliable implementation for iPad / desktop)
function initNavDrag(){
  const switchEl = document.querySelector('.nav-glass-switch');
  if(!switchEl) return;
  const blob = switchEl.querySelector('.nav-blob');
  const buttons = Array.from(switchEl.querySelectorAll('.nav-btn'));
  let activeIndex = buttons.findIndex(b=>b.classList.contains('active'));
  if(activeIndex < 0) activeIndex = 0;
  // Helper to snap blob to active button
  function snapToActive(animate=true){
    const btn = buttons[activeIndex];
    if(!btn) return;
    const rect = btn.getBoundingClientRect();
    const parentRect = switchEl.getBoundingClientRect();
    const left = rect.left - parentRect.left;
    blob.style.width = rect.width + 'px';
    if(!animate){
      switchEl.classList.add('dragging');
      blob.style.setProperty('--blob-x', left + 'px');
      switchEl.offsetHeight; // force layout
      switchEl.classList.remove('dragging');
    } else {
      blob.style.setProperty('--blob-x', left + 'px');
    }
  }
  snapToActive(false);
  // Click / tap activation
  buttons.forEach((btn,i)=>{
    btn.dataset.index = i;
    btn.addEventListener('click', ()=>{ activeIndex=i; showPage(btn.dataset.target, btn); snapToActive(true); });
    btn.addEventListener('touchstart', (e)=>{ e.preventDefault(); activeIndex=i; showPage(btn.dataset.target, btn); snapToActive(true); }, {passive:false});
  });
  // Drag state
  let dragging = false; let startX = 0; let originX = 0; let maxX = 0;
  function pointerDown(e){
    if(e.type==='mousedown' && e.button!==0) return;
    if(!switchEl.contains(e.target)) return;
    dragging = true; window.navDragging = true; switchEl.classList.add('dragging');
    const parentRect = switchEl.getBoundingClientRect();
    const activeBtn = buttons[activeIndex];
    const btnRect = activeBtn.getBoundingClientRect();
    originX = btnRect.left - parentRect.left;
    startX = e.touches ? e.touches[0].clientX : e.clientX;
    blob.style.width = btnRect.width + 'px';
    maxX = parentRect.width - btnRect.width - 8; // padding safeguard
    e.preventDefault();
  }
  function pointerMove(e){
    if(!dragging) return;
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    let x = originX + (clientX - startX);
    if(x < 0) x = 0; if(x > maxX) x = maxX;
    blob.style.setProperty('--blob-x', x + 'px');
    // Determine nearest button
    const parentRect = switchEl.getBoundingClientRect();
    const center = x + blob.offsetWidth/2;
    let nearest = activeIndex; let best = Infinity;
    buttons.forEach((btn,i)=>{
      const r = btn.getBoundingClientRect();
      const c = r.left - parentRect.left + r.width/2;
      const d = Math.abs(c - center);
      if(d < best){ best = d; nearest = i; }
    });
    activeIndex = nearest;
    e.preventDefault();
  }
  function pointerUp(e){
    if(!dragging) return;
    dragging = false; window.navDragging = false; switchEl.classList.remove('dragging');
    const btn = buttons[activeIndex];
    if(btn){ showPage(btn.dataset.target, btn); }
    snapToActive(true);
    e.preventDefault();
  }
  // Event listeners
  ['pointerdown','mousedown','touchstart'].forEach(ev=> switchEl.addEventListener(ev, pointerDown, {passive:false}));
  ['pointermove','mousemove','touchmove'].forEach(ev=> window.addEventListener(ev, pointerMove, {passive:false}));
  ['pointerup','mouseup','touchend','touchcancel','mouseleave'].forEach(ev=> window.addEventListener(ev, pointerUp, {passive:false}));
  window.addEventListener('resize', ()=>{ if(!dragging) snapToActive(true); });
}
window.addEventListener('load', initNavDrag);
// Ensure correct target inputs visibility on load
updateTargetInputVisibility();
    </script>
</body>
</html>