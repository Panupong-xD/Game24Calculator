<!DOCTYPE html>
<html lang="th">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ตัวเลขและผลลัพธ์ที่เป็นไปได้</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <!-- Navigation -->
    <div class="nav-container">
      <!-- New liquid glass segmented control -->
      <div class="nav-glass-switch">
        <div class="nav-blob"></div>
        <button class="nav-btn nav-tab active" onclick="showPage('calculation-page', this);" data-target="calculation-page">การคำนวณ</button>
        <button class="nav-btn nav-tab" onclick="showPage('settings-page', this);" data-target="settings-page">การตั้งค่า</button>
      </div>
      <div class="theme-toggle" onclick="toggleTheme()"></div>
    </div>

    <!-- Main Content -->
    <div class="main-container">
      <!-- Calculation Page -->
      <div id="calculation-page" class="page active">
        <div class="container">
          <h1>คำนวณผลลัพธ์ที่เป็นไปได้</h1>
          <p>กรอกตัวเลขและผลลัพธ์ที่ต้องการคำนวณ (number, pi, e)</p>
          <div id="numbers" class="number-container"></div>
          <button class="add-btn" onclick="addNumber()">+</button>
          <button class="remove-btn" onclick="removeNumber()">-</button>
          <br />
          <input
            type="text"
            id="target"
            placeholder="ผลลัพธ์"
            class="easy-input"
          />
          <br />
          <button class="calc-btn" onclick="findSolutions()">ค้นหาคำตอบ</button>
          <div id="results"></div>
        </div>
      </div>

      <!-- Updated Settings Page -->
      <div id="settings-page" class="page">
        <div class="container">
          <h1>การตั้งค่า</h1>
          <p>ปรับแต่งการทำงานของเครื่องมือคำนวณ</p>
          
          <div class="settings-options">
            <div class="option-group">
              <h3>ตัวเลือกการคำนวณ</h3>
              <div class="operator-buttons">
                <!-- Replace * and / visible text with × and ÷ -->
                <button id="toggleAddBtn" class="toggle-btn" onclick="toggleOperator('+')">เปิดการใช้ +</button>
                <button id="toggleSubBtn" class="toggle-btn" onclick="toggleOperator('-')">เปิดการใช้ -</button>
                <button id="toggleMulBtn" class="toggle-btn" onclick="toggleOperator('*')">เปิดการใช้ ×</button>
                <button id="toggleDivBtn" class="toggle-btn" onclick="toggleOperator('/')">เปิดการใช้ ÷</button>
                <button id="toggleModBtn" class="toggle-btn" onclick="toggleOperator('%')">เปิดการใช้ mod</button>
                <button id="togglePowBtn" class="toggle-btn" onclick="toggleOperator('^')">เปิดการใช้ ^</button>
                <button id="toggleConcatBtn" class="toggle-btn" onclick="toggleOperator('||')">เปิดการใช้ concat</button>
                <button id="toggleSumBtn" class="toggle-btn" onclick="toggleOperator('∑')">เปิดการใช้ ∑</button>
                <br>
                <button id="toggleSqrtBtn" class="toggle-btn" onclick="toggleOperator('√')">เปิดการใช้ √</button>
                <div id="sqrt-depth-container" class="sqrt-depth-container">
                  <label for="sqrt-depth">ระดับการซ้อน √ สูงสุด: </label>
                  <input
                    type="number"
                    id="sqrt-depth"
                    class="sqrt-depth-input"
                    min="1"
                    value="1"
                    onchange="updateMaxSqrtDepth()"
                  />
                </div>
                <button id="toggleFactBtn" class="toggle-btn" onclick="toggleOperator('!')">เปิดการใช้ !</button>
                <div id="fact-depth-container" class="fact-depth-container" style="display:none;">
                  <label for="fact-depth">ระดับการซ้อน ! สูงสุด: </label>
                  <input
                    type="number"
                    id="fact-depth"
                    class="fact-depth-input"
                    min="1"
                    value="1"
                    onchange="updateMaxFactDepth()"
                  />
                </div>
                <!-- NEW log operator -->
                <button id="toggleLogBtn" class="toggle-btn" onclick="toggleOperator('log')">เปิดการใช้ log</button>
                <div id="log-depth-container" class="log-depth-container" style="display:none;">
                  <label for="log-depth">ระดับการซ้อน log สูงสุด: </label>
                  <input type="number" id="log-depth" class="log-depth-input" min="1" value="1" onchange="updateMaxLogDepth()" />
                </div>
                <!-- NEW ln operator -->
                <button id="toggleLnBtn" class="toggle-btn" onclick="toggleOperator('ln')">เปิดการใช้ ln</button>
                <div id="ln-depth-container" class="log-depth-container" style="display:none;">
                  <label for="ln-depth">ระดับการซ้อน ln สูงสุด: </label>
                  <input type="number" id="ln-depth" class="log-depth-input" min="1" value="1" onchange="updateMaxLnDepth()" />
                </div>
              </div>
              <button id="toggleFastModeBtn" onclick="toggleFastMode()" class="toggle-btn mode-btn">เปิดโหมดหาคำตอบเร็ว</button>
              <div id="fast-accuracy-container" class="fast-accuracy-container" style="display:none; margin-top:8px;">
                <label for="fast-accuracy-slider" style="display:block; font-size:0.9rem; margin-bottom:4px;">ปรับสมดุล: ความเร็ว ←→ ความแม่น</label>
                <input type="range" id="fast-accuracy-slider" min="0" max="100" value="60" oninput="updateFastAccuracyLabel()" />
                <div id="fast-accuracy-label" style="font-size:0.8rem; margin-top:2px; opacity:0.8;">สมดุล (60)</div>
              </div>
              <button id="toggleIntegerModeBtn" onclick="toggleIntegerMode()" class="toggle-btn mode-btn">เปิดโหมดจำนวนเต็ม</button>
              <button id="toggleCleanModeBtn" onclick="toggleCleanMode()" class="toggle-btn mode-btn">เปิดโหมดคลีน</button>
              <button id="toggleSubsetModeBtn" onclick="toggleSubsetMode()" class="toggle-btn mode-btn">เปิดโหมดใช้บางตัวเลขได้</button>
            </div>
            
          </div>
        </div>
      </div>
    </div>

    <!-- JavaScript -->
    <script src="wasm-math.js"></script>
    <script>
// Page Navigation (refactored to avoid reliance on global event)
function showPage(pageId, sourceBtn=null) {
  // switch page visibility
  document.querySelectorAll('.page').forEach(p=>p.classList.remove('active'));
  const pageEl = document.getElementById(pageId);
  if(pageEl) pageEl.classList.add('active');
  // update active nav button
  const buttons = document.querySelectorAll('.nav-glass-switch .nav-btn');
  buttons.forEach(btn=>btn.classList.remove('active'));
  let targetBtn = sourceBtn || document.querySelector(`.nav-glass-switch .nav-btn[data-target="${pageId}"]`);
  if(targetBtn) targetBtn.classList.add('active');
  // sync blob position after layout
  requestAnimationFrame(()=> updateNavBlob());
}

// Core variables
let operatorFlags = { '+': true, '-': true, '*': true, '/': true, '%': false, '^': false, '√': false, '!': false, '||': false, '∑': false, 'log': false, 'ln': false };// added log, ln
let useFastMode = false;
let useIntegerMode = false;
let useCleanMode = false; // NEW: efficiency / clean mode
let useSubsetMode = false; // NEW: subset mode allowing partial use
// Added: speed-accuracy tuning (0=สุดเร็ว,1=สุดแม่น)
let fastAccuracy = 0.60; // default bias to slightly accuracy
let isCalculating = false;
let cancelCalculation = false;
let activeWorkers = [];
let MAX_SQRT_DEPTH = 1;
let MAX_FACT_DEPTH = 1;
let MAX_LOG_DEPTH = 1;
let MAX_LN_DEPTH = 1;
const MAX_FACTORIAL_INPUT = 12;
const MAX_RESULTS = 100;
const CHUNK_SIZE = 20;
const MAX_INPUT_NUMBERS = 8;
// NEW: track calculation start time
let calcStartTime = 0;

const factorialCache = new Map();
const calculationCache = new Map();
const expressionCache = new Map();

// UI Control Functions
document.body.classList.add('light-theme');

function toggleTheme() {
  document.body.classList.toggle('light-theme');
  document.body.classList.toggle('dark-theme');
  // ensure blob still aligned after theme transition
  setTimeout(updateNavBlob, 300);
}

function displayOperatorLabel(op){
  if(op==='*') return '×';
  if(op=== '/') return '÷';
  if(op=== '%') return 'mod';
  if(op==='||') return 'concat';
  if(op==='∑') return '∑';
  if(op==='ln') return 'ln';
  return op;
}

function toggleOperator(op) {
  operatorFlags[op] = !operatorFlags[op];
  const btn = document.getElementById(`toggle${op === '+' ? 'Add' : op === '-' ? 'Sub' : op === '*' ? 'Mul' : op === '/' ? 'Div' : op === '%' ? 'Mod' : op === '^' ? 'Pow' : op === '√' ? 'Sqrt' : op === '!' ? 'Fact' : op === '||' ? 'Concat' : op === '∑' ? 'Sum' : op === 'log' ? 'Log' : op === 'ln' ? 'Ln' : 'UNKNOWN'}Btn`);
  const disp = displayOperatorLabel(op);
  if (operatorFlags[op]) {
    btn.textContent = `ปิดการใช้ ${disp}`;
    btn.classList.add('active');
    if (op === '√') document.getElementById("sqrt-depth-container").classList.add("active");
    if (op === '!') document.getElementById("fact-depth-container").style.display = "block";
  if (op === 'log') document.getElementById('log-depth-container').style.display = 'block';
  if (op === 'ln') document.getElementById('ln-depth-container').style.display = 'block';
  } else {
    btn.textContent = `เปิดการใช้ ${disp}`;
    btn.classList.remove('active');
    if (op === '√') document.getElementById("sqrt-depth-container").classList.remove("active");
    if (op === '!') document.getElementById("fact-depth-container").style.display = "none";
  if (op === 'log') document.getElementById('log-depth-container').style.display = 'none';
  if (op === 'ln') document.getElementById('ln-depth-container').style.display = 'none';
  }
}

document.getElementById("toggleAddBtn").classList.add('active');
document.getElementById("toggleSubBtn").classList.add('active');
document.getElementById("toggleMulBtn").classList.add('active');
document.getElementById("toggleDivBtn").classList.add('active');

function updateNavBlob(){
  if(window.navDragging) return; // อย่าบังคับตำแหน่งระหว่างลาก
  const switchEl = document.querySelector('.nav-glass-switch');
  const blob = switchEl?.querySelector('.nav-blob');
  const active = switchEl?.querySelector('.nav-btn.active');
  if(!blob || !active || !switchEl) return;
  const rect = active.getBoundingClientRect();
  const parentRect = switchEl.getBoundingClientRect();
  const left = rect.left - parentRect.left;
  if(typeof window.prevBlobLeft === 'undefined') window.prevBlobLeft = left;
  const delta = left - window.prevBlobLeft;
  const adelta = Math.abs(delta);
  blob.classList.remove('squish-light','squish-medium','squish-strong');
  if(adelta > 60) blob.classList.add('squish-strong');
  else if(adelta > 25) blob.classList.add('squish-medium');
  else blob.classList.add('squish-light');
  blob.style.width = rect.width + 'px';
  blob.style.setProperty('--blob-x', left + 'px');
  window.prevBlobLeft = left;
}

window.addEventListener('resize', ()=> requestAnimationFrame(updateNavBlob));
window.addEventListener('orientationchange', ()=> setTimeout(updateNavBlob,150));
window.addEventListener('load', ()=> setTimeout(updateNavBlob,50));

function toggleFastMode() {
  useFastMode = !useFastMode;
  const btn = document.getElementById("toggleFastModeBtn");
  const container = document.getElementById('fast-accuracy-container');
  if (useFastMode) {
    btn.textContent = "ปิดโหมดหาคำตอบเร็ว";
    btn.classList.add('active-mode');
    container.style.display = 'block';
  } else {
    btn.textContent = "เปิดโหมดหาคำตอบเร็ว";
    btn.classList.remove('active-mode');
    container.style.display = 'none';
  }
}
function updateFastAccuracyLabel(){
  const slider = document.getElementById('fast-accuracy-slider');
  if(!slider) return;
  fastAccuracy = slider.value/100; // 0..1
  const timeBudgetSec = (slider.value/5).toFixed(2); // explicit mapping 0..20s
  // sync filled gradient length
  slider.style.setProperty('--progress', fastAccuracy.toString());
  let txt;
  if(fastAccuracy < 0.15) txt='เร็วที่สุด';
  else if(fastAccuracy < 0.35) txt='เร็วมาก';
  else if(fastAccuracy < 0.55) txt='ค่อนข้างเร็ว';
  else if(fastAccuracy < 0.70) txt='สมดุล';
  else if(fastAccuracy < 0.85) txt='ค่อนข้างแม่น';
  else if(fastAccuracy < 0.95) txt='แม่นมาก';
  else txt='แม่นสูงสุด';
  // Show explicit time budget mapping
  document.getElementById('fast-accuracy-label').textContent = `${txt} (${slider.value}) • เวลา ≤ ${timeBudgetSec}s`;
}
// init label once
updateFastAccuracyLabel();

(function(){
  const slider = document.getElementById('fast-accuracy-slider');
  if(!slider) return;

  const isiOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform==='MacIntel' && navigator.maxTouchPoints>1);

  // Internal state
  let isDown = false; let lastX=null; let lastT=null; let velocity=0; let rafDecay=null; let frame=null;
  const MAX_ABS_V = 3200; // clamp
  const MIN_ABS_V = 18;
  const BASE_STRETCH = 0.24; // magnitude scaling
  const DECAY = 0.88; // velocity decay per frame
  let recoilAnimating=false, recoilStart=0; const RECOIL_MS=380;

  function setVar(name,val){ slider.style.setProperty(name,val); }
  function startRecoil(){
    recoilAnimating=true; recoilStart=performance.now();
    // initial overshoot (tall & narrow)
    setVar('--recoil-x','0.78');
    setVar('--recoil-y','1.22');
    requestAnimationFrame(stepRecoil);
  }
  function stepRecoil(){
    if(!recoilAnimating) return;
    const now=performance.now();
    const t=Math.min(1,(now-recoilStart)/RECOIL_MS);
    // ease out elastic-ish
    // custom curve: blend of easeOutCubic and small damping oscillation
    const ease = 1 - Math.pow(1-t,3);
    // damp oscillation factor
    const osc = Math.sin(t*3.4*Math.PI) * (1-t)*0.12;
    const targetX = 1; const startX=0.78; const currentX = startX + (targetX-startX)*ease + osc;
    const targetY = 1; const startY=1.22; const currentY = startY + (targetY-startY)*ease - osc*0.85;
    setVar('--recoil-x', currentX.toFixed(4));
    setVar('--recoil-y', currentY.toFixed(4));
    if(t>=1){ recoilAnimating=false; setVar('--recoil-x','1'); setVar('--recoil-y','1'); return; }
    requestAnimationFrame(stepRecoil);
  }

  function press(){ slider.classList.remove('glass-release'); slider.offsetHeight; slider.classList.add('glass-press'); }
  function release(){ slider.classList.remove('glass-press'); slider.classList.add('glass-release'); startRecoil(); }

  function getClientX(e){ return e.touches? e.touches[0].clientX : e.clientX; }

  function pointerDown(e){ if(isDown) return; isDown=true; lastX=getClientX(e); lastT=performance.now(); velocity=0; if(rafDecay) cancelAnimationFrame(rafDecay); rafDecay=null; press(); }
  function pointerMove(e){ if(!isDown) return; const now=performance.now(); const x=getClientX(e); const dt=(now-lastT)/1000; if(lastX!=null && dt>0){ const dx=x-lastX; velocity = dx/dt; applyStretch(velocity); } lastX=x; lastT=now; }
  function pointerUp(){ if(!isDown) return; isDown=false; release(); if(rafDecay) cancelAnimationFrame(rafDecay); rafDecay=requestAnimationFrame(decay); }

  // Update progress custom property for blue tube (since native range won't update our gradient automatically in all engines)
  function syncProgress(){ const val=parseFloat(slider.value||0); const min=parseFloat(slider.min||0); const max=parseFloat(slider.max||100); const ratio=(val-min)/(max-min); setVar('--progress', ratio.toString()); }
  slider.addEventListener('input', syncProgress, {passive:true});
  syncProgress();

  // Events (support pointer + touch + mouse)
  slider.addEventListener('pointerdown', pointerDown, {passive:true});
  slider.addEventListener('touchstart', pointerDown, {passive:true});
  slider.addEventListener('mousedown', pointerDown, {passive:true});

  window.addEventListener('pointermove', pointerMove, {passive:true});
  window.addEventListener('touchmove', pointerMove, {passive:true});
  window.addEventListener('mousemove', pointerMove, {passive:true});

  window.addEventListener('pointerup', pointerUp, {passive:true});
  window.addEventListener('touchend', pointerUp, {passive:true});
  window.addEventListener('mouseup', pointerUp, {passive:true});
  window.addEventListener('touchcancel', pointerUp, {passive:true});

  // iOS direct transform fallback if CSS var scaling jank detected
  if(isiOS){
    // Attempt heuristic: adapt transforms via style injection each frame (here our slider thumb isn't a direct element we can easily select; for WebKit we rely on pseudo element). We'll keep CSS variable method; Safari 16+ handles it. If needed, future enhancement could use overlay custom thumb.
  }
})();

function toggleIntegerMode() {
  useIntegerMode = !useIntegerMode;
  const btn = document.getElementById("toggleIntegerModeBtn");
  if (useIntegerMode) {
    btn.textContent = "ปิดโหมดจำนวนเต็ม";
    btn.classList.add('active-mode');
  } else {
    btn.textContent = "เปิดโหมดจำนวนเต็ม";
    btn.classList.remove('active-mode');
  }
}

function toggleCleanMode(){
  useCleanMode = !useCleanMode;
  const btn = document.getElementById('toggleCleanModeBtn');
  if(useCleanMode){
    btn.textContent = 'ปิดโหมดคลีน';
    btn.classList.add('active-mode');
  } else {
    btn.textContent = 'เปิดโหมดคลีน';
    btn.classList.remove('active-mode');
  }
}
function toggleSubsetMode(){
  useSubsetMode = !useSubsetMode;
  const btn = document.getElementById('toggleSubsetModeBtn');
  if(!btn) return;
  if(useSubsetMode){ btn.textContent='ปิดโหมดใช้บางตัวเลขได้'; btn.classList.add('active-mode'); }
  else { btn.textContent='เปิดโหมดใช้บางตัวเลขได้'; btn.classList.remove('active-mode'); }
}

function updateMaxSqrtDepth() {
  const input = document.getElementById("sqrt-depth");
  const value = parseInt(input.value);
  if (!isNaN(value) && value >= 1) MAX_SQRT_DEPTH = value;
  else input.value = MAX_SQRT_DEPTH;
}

function updateMaxFactDepth() {
  const input = document.getElementById("fact-depth");
  const value = parseInt(input.value);
  if (!isNaN(value) && value >= 1) MAX_FACT_DEPTH = value;
  else input.value = MAX_FACT_DEPTH;
}

function updateMaxLogDepth(){
  const input = document.getElementById('log-depth');
  const v = parseInt(input.value);
  if(!isNaN(v) && v>=1) MAX_LOG_DEPTH = v; else input.value = MAX_LOG_DEPTH;
}

function updateMaxLnDepth(){
  const input = document.getElementById('ln-depth');
  const v = parseInt(input.value);
  if(!isNaN(v) && v>=1) MAX_LN_DEPTH = v; else input.value = MAX_LN_DEPTH;
}

function addNumber() {
  let numbers = document.querySelectorAll(".num-container");
  if (numbers.length < MAX_INPUT_NUMBERS) {
    let div = document.createElement("div");
    div.className = "num-container";
    let input = document.createElement("input");
  input.type = "text";
    input.className = "num";
  input.placeholder = "0";
    div.appendChild(input);
    document.getElementById("numbers").appendChild(div);
  }
}

function removeNumber() {
  let numbers = document.getElementById("numbers");
  if (numbers.children.length > 1) numbers.removeChild(numbers.lastChild);
}

// Basic Calculation Functions
function factorial(n) {
  if (n < 0 || n > MAX_FACTORIAL_INPUT || !Number.isInteger(n)) return NaN;
  if (n === 0 || n === 1) return 1;
  if (factorialCache.has(n)) return factorialCache.get(n);
  
  // Use WebAssembly if available
  let result;
  if (window.wasmMath && window.wasmMath.isReady) {
    result = window.wasmMath.factorial(n);
  } else {
    // JavaScript fallback
    result = 1;
    for (let i = 2; i <= n; i++) result *= i;
  }
  
  factorialCache.set(n, result);
  return result;
}

function evaluateAST(node) {
  if (node.type === "num") return node.value;
  let leftVal = node.left ? evaluateAST(node.left) : null;
  let rightVal = evaluateAST(node.right);
  const cacheKey = `${node.operator}|${leftVal}|${rightVal}`;
  if (calculationCache.has(cacheKey)) return calculationCache.get(cacheKey);
  let result;
  if (window.wasmMath && window.wasmMath.isReady) {
    switch (node.operator) {
      case "+": 
        result = operatorFlags['+'] ? window.wasmMath.add(leftVal, rightVal) : NaN; 
        break;
      case "-": 
        result = operatorFlags['-'] ? window.wasmMath.sub(leftVal, rightVal) : NaN; 
        break;
      case "*": 
        result = operatorFlags['*'] ? window.wasmMath.mul(leftVal, rightVal) : NaN; 
        break;
      case "/": 
        result = operatorFlags['/'] && rightVal !== 0 ? window.wasmMath.div(leftVal, rightVal) : NaN; 
        break;
      case "%":
        if (!operatorFlags['%'] || rightVal === 0) return NaN;
        result = leftVal - rightVal * Math.floor(leftVal / rightVal);
        break;
      case "^":
        if (!operatorFlags['^']) return NaN;
        result = (leftVal === 0 && rightVal <= 0) ? (rightVal === 0 ? 1 : NaN) : window.wasmMath.pow(leftVal, rightVal);
        break;
      case "√": 
        result = operatorFlags['√'] && rightVal >= 0 ? window.wasmMath.sqrt(rightVal) : NaN; 
        break;
      case "!": 
        result = operatorFlags['!'] && rightVal <= MAX_FACTORIAL_INPUT && rightVal >= 0 && Number.isInteger(rightVal) ? window.wasmMath.factorial(rightVal) : NaN; 
        break;
      case "||": {
        if(!operatorFlags['||']) { result = NaN; break; }
        if(!Number.isInteger(leftVal) || !Number.isInteger(rightVal) || leftVal < 0 || rightVal < 0) { result = NaN; break; }
        const concatVal = parseFloat(String(Math.trunc(leftVal)) + String(Math.trunc(rightVal)));
        result = concatVal;
        break; }
      case "∑": {
        if(!operatorFlags['∑']) { result = NaN; break; }
        if(!Number.isInteger(leftVal) || !Number.isInteger(rightVal)) { result = NaN; break; }
        if(leftVal > rightVal){ result = NaN; break; }
        const n = rightVal - leftVal + 1;
        result = (leftVal + rightVal) * n / 2;
        break; }
      case "log": {
        result = operatorFlags['log'] && rightVal>0 ? Math.log10(rightVal) : NaN;
        break;
      }
      case "ln": {
        result = operatorFlags['ln'] && rightVal>0 ? Math.log(rightVal) : NaN;
        break;
      }
      default: return NaN;
    }
  } else {
    switch (node.operator) {
      case "+": result = operatorFlags['+'] ? leftVal + rightVal : NaN; break;
      case "-": result = operatorFlags['-'] ? leftVal - rightVal : NaN; break;
      case "*": result = operatorFlags['*'] ? leftVal * rightVal : NaN; break;
      case "/": result = operatorFlags['/'] && rightVal !== 0 ? leftVal / rightVal : NaN; break;
      case "%":
        if (!operatorFlags['%'] || rightVal === 0) return NaN;
        result = leftVal - rightVal * Math.floor(leftVal / rightVal); break;
      case "^":
        if (!operatorFlags['^']) return NaN;
        result = (leftVal === 0 && rightVal <= 0) ? (rightVal === 0 ? 1 : NaN) : Math.pow(leftVal, rightVal); break;
      case "√": result = operatorFlags['√'] && rightVal >= 0 ? Math.sqrt(rightVal) : NaN; break;
      case "!": result = operatorFlags['!'] && rightVal <= MAX_FACTORIAL_INPUT && rightVal >= 0 && Number.isInteger(rightVal) ? factorial(rightVal) : NaN; break;
      case "||": {
        if(!operatorFlags['||']) { result = NaN; break; }
        if(!Number.isInteger(leftVal) || !Number.isInteger(rightVal) || leftVal < 0 || rightVal < 0) { result = NaN; break; }
        result = parseFloat(String(Math.trunc(leftVal)) + String(Math.trunc(rightVal))); break; }
      case "∑": {
        if(!operatorFlags['∑']) { result = NaN; break; }
        if(!Number.isInteger(leftVal) || !Number.isInteger(rightVal) || leftVal > rightVal){ result = NaN; break; }
        const n = rightVal - leftVal + 1; result = (leftVal + rightVal) * n / 2; break; }
      case "log": {
        result = operatorFlags['log'] && rightVal>0 ? Math.log10(rightVal) : NaN;
        break;
      }
      case "ln": {
        result = operatorFlags['ln'] && rightVal>0 ? Math.log(rightVal) : NaN;
        break;
      }
      default: return NaN;
    }
  }
  if (!isNaN(result)) {
    if (calculationCache.size > 1000000) calculationCache.clear();
    calculationCache.set(cacheKey, result);
  }
  return result;
}

function isIntegerResult(result) {
  return Number.isInteger(result) || Math.abs(result - Math.round(result)) < 0.0001;
}

function serializeAST(node) {
  if (node.type === "num") return node.value.toString();
  if (node.operator === "√") return `√(${serializeAST(node.right)})`;
  if (node.operator === "!") return `(${serializeAST(node.right)})!`;
  if (node.operator === "log") return `log(${serializeAST(node.right)})`;
  if (node.operator === "ln") return `ln(${serializeAST(node.right)})`;
  return `(${node.left ? serializeAST(node.left) : ""} ${node.operator} ${serializeAST(node.right)})`;
}

function canonicalizeAST(node) {
  if (node.type === "num") return node;
  let left = node.left ? canonicalizeAST(node.left) : null;
  let right = canonicalizeAST(node.right);
  if (node.operator === "+" || node.operator === "*" || node.operator === "%") {
    let leftStr = serializeAST(left);
    let rightStr = serializeAST(right);
    if (leftStr > rightStr) return { type: "op", operator: node.operator, left: right, right: left };
  }
  return { type: "op", operator: node.operator, left, right };
}

function getSqrtDepth(node) {
  if (node.type === "num") return 0;
  if (node.operator === "√") return 1 + getSqrtDepth(node.right);
  let leftDepth = node.left ? getSqrtDepth(node.left) : 0;
  let rightDepth = node.right ? getSqrtDepth(node.right) : 0;
  return Math.max(leftDepth, rightDepth);
}

function getFactDepth(node) {
  if (node.type === "num") return 0;
  if (node.operator === "!") return 1 + getFactDepth(node.right);
  let leftDepth = node.left ? getFactDepth(node.left) : 0;
  let rightDepth = node.right ? getFactDepth(node.right) : 0;
  return Math.max(leftDepth, rightDepth);
}

function getLogDepth(node){ if(node.type==='num') return 0; if(node.operator==='log') return 1+getLogDepth(node.right); const ld=node.left?getLogDepth(node.left):0; const rd=node.right?getLogDepth(node.right):0; return Math.max(ld,rd); }
function getLnDepth(node){ if(node.type==='num') return 0; if(node.operator==='ln') return 1+getLnDepth(node.right); const ld=node.left?getLnDepth(node.left):0; const rd=node.right?getLnDepth(node.right):0; return Math.max(ld,rd); }

function generateAllGroupings(nums, target) {
  const memoized = new Map();
  function generateGroupingsHelper(start, end) {
    const key = `${start}-${end}`;
    if (memoized.has(key)) return memoized.get(key);
    const result = [];
    if (start === end) {
      const numNode = { type: "num", value: nums[start] };
      result.push(numNode);
      if (operatorFlags['√'] && nums[start] >= 0 && (!useIntegerMode || Number.isInteger(Math.sqrt(nums[start])))) {
        let currentExpr = numNode;
        for (let i = 1; i <= MAX_SQRT_DEPTH && operatorFlags['√']; i++) {
          currentExpr = { type: "op", operator: "√", left: null, right: currentExpr };
          const sqrtResult = evaluateAST(currentExpr);
            if (!isNaN(sqrtResult) && (!useIntegerMode || isIntegerResult(sqrtResult))) result.push(currentExpr);
            else break;
        }
      }
      if (operatorFlags['!'] && nums[start] >= 0 && nums[start] <= MAX_FACTORIAL_INPUT && Number.isInteger(nums[start])) {
        let currentExpr = numNode;
        for (let i = 1; i <= MAX_FACT_DEPTH && operatorFlags['!']; i++) {
          currentExpr = { type: "op", operator: "!", left: null, right: currentExpr };
          const factResult = evaluateAST(currentExpr);
          if (!isNaN(factResult)) result.push(currentExpr); else break;
        }
      }
      // NEW: base case log nesting
      if (operatorFlags['log'] && nums[start] > 0){
        let currentExpr = numNode;
        for(let i=1;i<=MAX_LOG_DEPTH && operatorFlags['log'];i++){
          currentExpr = { type:'op', operator:'log', left:null, right: currentExpr };
          const logResult = evaluateAST(currentExpr);
          if(!isNaN(logResult) && (!useIntegerMode || isIntegerResult(logResult))) result.push(currentExpr); else break;
        }
      }
      // NEW: base case ln nesting
      if (operatorFlags['ln'] && nums[start] > 0){
        let currentExpr = numNode;
        for(let i=1;i<=MAX_LN_DEPTH && operatorFlags['ln'];i++){
          currentExpr = { type:'op', operator:'ln', left:null, right: currentExpr };
          const logResult = evaluateAST(currentExpr);
          if(!isNaN(logResult) && (!useIntegerMode || isIntegerResult(logResult))) result.push(currentExpr); else break;
        }
      }
    } else {
      for (let i = start; i < end; i++) {
        const leftExprs = generateGroupingsHelper(start, i);
        const rightExprs = generateGroupingsHelper(i + 1, end);
        for (const left of leftExprs) {
          for (const right of rightExprs) {
            const operators = [];
            if (operatorFlags['+']) operators.push("+");
            if (operatorFlags['-']) operators.push("-");
            if (operatorFlags['*']) operators.push("*");
            if (operatorFlags['/']) operators.push("/");
            if (operatorFlags['%']) operators.push("%");
            if (operatorFlags['^']) operators.push("^");
            for (const op of operators) {
              if (op === "/" && evaluateAST(right) === 0) continue;
              if (op === "%" && evaluateAST(right) === 0) continue;
              if (op === "^" && evaluateAST(left) === 0 && evaluateAST(right) <= 0) continue;
              const newExpr = { type: "op", operator: op, left, right };
              const resultVal = evaluateAST(newExpr);
              if (isNaN(resultVal)) continue;
              if (!useIntegerMode || isIntegerResult(resultVal)) {
                result.push(newExpr);
                if (operatorFlags['√'] && getSqrtDepth(newExpr) < MAX_SQRT_DEPTH) {
                  const sqrtValue = evaluateAST(newExpr);
                  if (!isNaN(sqrtValue) && sqrtValue >= 0) {
                    let currentExpr = newExpr;
                    for (let depth = 1; depth <= MAX_SQRT_DEPTH - getSqrtDepth(newExpr); depth++) {
                      currentExpr = { type: "op", operator: "√", left: null, right: currentExpr };
                      const sqrtResult = evaluateAST(currentExpr);
                      if (!isNaN(sqrtResult) && (!useIntegerMode || isIntegerResult(sqrtResult))) result.push(currentExpr); else break;
                    }
                  }
                }
                if (operatorFlags['!'] && getFactDepth(newExpr) < MAX_FACT_DEPTH) {
                  const factValue = evaluateAST(newExpr);
                  if (!isNaN(factValue) && factValue >= 0 && factValue <= MAX_FACTORIAL_INPUT && Number.isInteger(factValue)) {
                    let currentExpr = newExpr;
                    for (let depth = 1; depth <= MAX_FACT_DEPTH - getFactDepth(newExpr); depth++) {
                      currentExpr = { type: "op", operator: "!", left: null, right: currentExpr };
                      const factResult = evaluateAST(currentExpr);
                      if (!isNaN(factResult)) result.push(currentExpr); else break;
                    }
                  }
                }
                // NEW: log chaining
                if (operatorFlags['log'] && getLogDepth(newExpr) < MAX_LOG_DEPTH){
                  const baseVal = evaluateAST(newExpr);
                  if(!isNaN(baseVal) && baseVal > 0){
                    let currentExpr = newExpr;
                    for(let depth=1; depth <= MAX_LOG_DEPTH - getLogDepth(newExpr); depth++){
                      currentExpr = { type:'op', operator:'log', left:null, right: currentExpr };
                      const logResult = evaluateAST(currentExpr);
                      if(!isNaN(logResult) && (!useIntegerMode || isIntegerResult(logResult))) result.push(currentExpr); else break;
                    }
                  }
                }
                // NEW: ln chaining (shares depth budget with log)
        if (operatorFlags['ln'] && getLnDepth(newExpr) < MAX_LN_DEPTH){
                  const baseVal = evaluateAST(newExpr);
                  if(!isNaN(baseVal) && baseVal > 0){
                    let currentExpr = newExpr;
          for(let depth=1; depth <= MAX_LN_DEPTH - getLnDepth(newExpr); depth++){
                      currentExpr = { type:'op', operator:'ln', left:null, right: currentExpr };
                      const logResult = evaluateAST(currentExpr);
                      if(!isNaN(logResult) && (!useIntegerMode || isIntegerResult(logResult))) result.push(currentExpr); else break;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    memoized.set(key, result);
    return result;
  }
  return generateGroupingsHelper(0, nums.length - 1);
}

// Flexible numeric formatting
function formatNumber(n) {
  if (Number.isInteger(n)) return n.toString();
  const s = n.toFixed(8); // high precision then trim
  return s.replace(/\.0+$/,'').replace(/(\.[0-9]*?)0+$/,'$1');
}

function parseNumberInput(s){
  if(typeof s !== 'string') return Number(s);
  const t = s.trim().toLowerCase();
  if(t === 'pi' || t === 'π') return Math.PI;
  if(t === 'e') return Math.E;
  return parseFloat(t);
}

function findSolutions() {
  if (isCalculating) return;
  isCalculating = true;
  cancelCalculation = false;
  activeWorkers = [];
  calcStartTime = performance.now(); // start timing

  const numContainers = document.querySelectorAll(".num-container");
  const nums = Array.from(numContainers)
    .map(container => parseNumberInput(container.querySelector(".num").value))
    .map(v => (isNaN(v) ? 0 : v));
  const target = parseNumberInput(document.getElementById("target").value);

  if (isNaN(target)) {
    document.getElementById("results").innerHTML = "<h2>กรุณากรอกผลลัพธ์ที่ต้องการ</h2>";
    isCalculating = false;
    return;
  }
  if (nums.length < 2) {
    document.getElementById("results").innerHTML = "<h2>กรุณาใส่ตัวเลขอย่างน้อย 2 ตัว</h2>";
    isCalculating = false;
    return;
  }

  document.getElementById("results").innerHTML = `
    <h2>กำลังเรียงสับเปลี่ยน...</h2>
    <button id="cancel-calc-btn" onclick="cancelCalculation = true; cancelAllWorkers();">ยกเลิกการคำนวณ</button>
  `;

  if (useFastMode) findFirstSolutionFast(nums, target);
  else if (useSubsetMode) findSubsetSolutionsParallel(nums, target);
  else findAllSolutionsParallel(nums, target);
}

// --- Subset Mode (partial usage) ---
function findSubsetSolutionsParallel(nums, target){
  const n=nums.length; if(n<2){ document.getElementById('results').innerHTML='<h2>ต้องมีอย่างน้อย 2 ตัว</h2>'; isCalculating=false; return; }
  // generate subsets (size >=2, allow full set too so user gets full answers inside this mode)
  const subsets=[]; for(let mask=1; mask < (1<<n); mask++){ let bits=mask; let size=0; while(bits){ size += bits & 1; bits >>=1; } if(size<2) continue; const subset=[]; for(let i=0;i<n;i++){ if(mask & (1<<i)) subset.push(nums[i]); } subsets.push(subset); }
  if(subsets.length===0){ document.getElementById('results').innerHTML='<h2>ไม่มีชุดย่อย</h2>'; isCalculating=false; return; }
  const total=subsets.length; const numWorkers = navigator.hardwareConcurrency || 4; activeWorkers.forEach(w=>w.terminate()); activeWorkers=[]; calcStartTime=performance.now();
  let completed=0; let closest=null; let smallestDiff=Infinity; const EXACT_EPS=1e-12; let lastUI=0; const inProgress=new Map(); let results=[];
  document.getElementById('results').innerHTML=`<h2>โหมดย่อย: เริ่ม...</h2><p>0/${total}</p><button id="cancel-calc-btn" onclick="cancelCalculation=true; cancelAllWorkers();">ยกเลิก</button>`;
  function ui(force=false){ const now=performance.now(); if(!force && now-lastUI<120) return; lastUI=now; const pct=Math.round((completed/total)*100); let cTxt='ยังไม่พบ'; if(closest){ cTxt = (closest.diff<=EXACT_EPS? `${prettyPrintExpression(closest.expression)} = ${formatNumber(closest.result)} (ตรงเป๊ะ)` : `${prettyPrintExpression(closest.expression)} = ${formatNumber(closest.result)} (ห่าง ${formatNumber(closest.diff)})`); }
    document.getElementById('results').innerHTML=`<h2>โหมดย่อย: ${pct}% (${completed}/${total})</h2><p>ดีที่สุด: ${cTxt}</p><button id=\"cancel-calc-btn\" onclick=\"cancelCalculation=true; cancelAllWorkers();\">ยกเลิก</button>`; }
  function finish(){ const elapsed=((performance.now()-calcStartTime)/1000).toFixed(3); if(results.length){ displayResults(results, elapsed); } else if(closest){ const head = closest.diff<=EXACT_EPS ? 'พบคำตอบตรงเป๊ะ (ชุดย่อย)' : 'คำตอบใกล้สุด (ชุดย่อย)'; document.getElementById('results').innerHTML=`<h2>${head}</h2>${renderElapsed(elapsed)}<ul><li>${prettyPrintExpression(closest.expression)} = ${formatNumber(closest.result)}${closest.diff<=EXACT_EPS?'':' (ห่าง '+formatNumber(closest.diff)+')'}</li></ul>`; } else { document.getElementById('results').innerHTML=`<h2>ไม่พบคำตอบ</h2>${renderElapsed(elapsed)}`; } isCalculating=false; activeWorkers.forEach(w=>w.terminate()); activeWorkers=[]; }
  let next=0; function assign(worker){ if(next>=total) return; const start=next; const end=start+1; next=end; inProgress.set(worker,0); worker._start=start; worker._end=end; worker.postMessage({ type:'findAllSubsetsRange', permutations: subsets, start, end, target, operatorFlags, useIntegerMode, MAX_SQRT_DEPTH, MAX_FACT_DEPTH, MAX_LOG_DEPTH, MAX_LN_DEPTH, MAX_FACTORIAL_INPUT, MAX_RESULTS: Infinity }); }
  for(let w=0; w<numWorkers; w++){ const worker=new Worker('worker.js'); activeWorkers.push(worker); worker.onmessage=e=>{ if(cancelCalculation) return; const d=e.data; if(d.progress){ if(d.closest && (!closest || d.closest.diff < closest.diff)){ closest=d.closest; } ui(); return; } if(d.results){ for(const r of d.results){ results.push(r); } } if(d.closest && (!closest || d.closest.diff < closest.diff)){ closest=d.closest; } completed += (worker._end - worker._start); inProgress.delete(worker); ui(true); if(completed>=total && inProgress.size===0){ finish(); return; } assign(worker); }; worker.onerror=()=>{ completed += (worker._end - worker._start)||0; inProgress.delete(worker); if(completed>=total && inProgress.size===0) finish(); else assign(worker); }; assign(worker); }
}

function findFirstSolutionFast(nums, target) {
  // explicit wall-clock time budget derived from slider: (value/5) seconds
  const slider = document.getElementById('fast-accuracy-slider');
  const sliderVal = slider ? parseInt(slider.value) : Math.round(fastAccuracy*100);
  const timeBudgetMs = (sliderVal/5)*1000; // 0..20000ms
  const maxSeconds = (timeBudgetMs/1000).toFixed(2);
  const elapsed = () => ((performance.now()-calcStartTime)/1000).toFixed(3);

  const numWorkers = navigator.hardwareConcurrency || 4;
  const workers = [];
  let found = false;
  let globalClosest = null; // accumulate best from all workers
  calculationCache.clear();
  expressionCache.clear();
  const workerPromises = [];

  // initial UI state for fast mode with time budget
  document.getElementById("results").innerHTML = `
    <h2>โหมดเร็ว: กำลังค้นหา (จำกัดเวลา ≤ ${maxSeconds}s)</h2>
    <p>กำลังประมวลผลหลายเธรด...</p>
    <button id="cancel-calc-btn" onclick="cancelCalculation = true; cancelAllWorkers();">ยกเลิกการคำนวณ</button>
  `;

  function updateProgressUI(){
    if(found) return;
    if(!globalClosest){
      document.getElementById("results").innerHTML = `
        <h2>โหมดเร็ว: กำลังค้นหา (≤ ${maxSeconds}s)</h2>
        <p>ยังไม่พบคำตอบใกล้เคียง</p>
        <button id="cancel-calc-btn" onclick="cancelCalculation = true; cancelAllWorkers();">ยกเลิกการคำนวณ</button>`;
      return;
    }
    const diff = globalClosest.diff;
    const EXACT_EPS = 1e-12;
    const status = diff <= EXACT_EPS ? '(ตรงเป๊ะ – เตรียมสรุป)' : `(ห่าง ${formatNumber(diff)})`;
    document.getElementById("results").innerHTML = `
      <h2>โหมดเร็ว: กำลังค้นหา (≤ ${maxSeconds}s)</h2>
      <p>คำตอบใกล้สุด: ${prettyPrintExpression(globalClosest.expression)} = ${formatNumber(globalClosest.result)} ${status}</p>
      <button id="cancel-calc-btn" onclick="cancelCalculation = true; cancelAllWorkers();">ยกเลิกการคำนวณ</button>`;
  }

  for (let i = 0; i < numWorkers; i++) {
    const worker = new Worker('worker.js');
    workers.push(worker);
    activeWorkers.push(worker);
    const promise = new Promise((resolve) => {
      worker.onmessage = function(e) {
        if(found) { resolve(); return; }
        if(e.data.progress){
          // progressive closest candidate update
            if(e.data.closest && (!globalClosest || e.data.closest.diff < globalClosest.diff)) {
              globalClosest = e.data.closest;
              window.closestResultOnCancel = globalClosest; // allow showing best if cancelled
              updateProgressUI();
            }
            return; // do not resolve yet
        }
        if (e.data.found && !found) {
          found = true;
          const { expression, result } = e.data;
          const t = elapsed();
          document.getElementById("results").innerHTML = `<h2>ผลลัพธ์</h2>${renderElapsed(t)}<ul><li>${prettyPrintExpression(expression)} = ${formatNumber(result)}</li></ul>`;
          terminateWorkers(workers);
          activeWorkers = [];
          isCalculating = false;
          resolve();
        } else if (e.data.closest && !found) {
          // final closest from a worker (worker finished its budget)
          if(!globalClosest || e.data.closest.diff < globalClosest.diff){
            globalClosest = e.data.closest;
            window.closestResultOnCancel = globalClosest;
          }
          // if all workers will resolve via Promise.all later
          resolve();
        } else if (e.data.finished) {
          resolve();
        }
      };
      worker.onerror = function(){ resolve(); };
    });
    workerPromises.push(promise);
    worker.postMessage({
      type: 'findFirstFast',
      nums,
      target,
      operatorFlags,
      useIntegerMode,
      MAX_SQRT_DEPTH,
      MAX_FACT_DEPTH,
      MAX_LOG_DEPTH,
      MAX_LN_DEPTH,
      MAX_FACTORIAL_INPUT,
      speedAccuracy: fastAccuracy, // keep heuristic scaling
      timeBudgetMs, // NEW explicit cap
      allowPartial: useSubsetMode // allow partial expressions only when subset mode active
    });
  }
  // periodic UI refresh while waiting
  const uiInterval = setInterval(()=>{ if(!isCalculating) { clearInterval(uiInterval); return; } updateProgressUI(); }, 250);
  Promise.all(workerPromises).then(()=>{
    clearInterval(uiInterval);
    if(found) return; // already handled
    if(globalClosest){
      const EXACT_EPS = 1e-12;
      const t=elapsed();
      if (Math.abs(globalClosest.diff) <= EXACT_EPS) {
        document.getElementById("results").innerHTML = `
          <h2>ผลลัพธ์</h2>
          ${renderElapsed(t)}
          <ul><li>${prettyPrintExpression(globalClosest.expression)} = ${formatNumber(globalClosest.result)} (ตรงเป๊ะ)</li></ul>`;
      } else {
        document.getElementById("results").innerHTML = `
          <h2>ไม่พบคำตอบที่ตรงเป๊ะ</h2>
          ${renderElapsed(t)}
          <h3>คำตอบที่ใกล้ที่สุด:</h3>
          <ul><li>${prettyPrintExpression(globalClosest.expression)} = ${formatNumber(globalClosest.result)} (ห่าง ${formatNumber(globalClosest.diff)})</li></ul>`;
      }
    } else {
      document.getElementById("results").innerHTML = `<h2>ไม่พบคำตอบภายใน ${maxSeconds}s</h2>${renderElapsed(elapsed())}`;
    }
    terminateWorkers(workers);
    activeWorkers=[];
    isCalculating=false;
  }).catch(()=>{
    clearInterval(uiInterval);
    document.getElementById("results").innerHTML = `<h2>เกิดข้อผิดพลาดในการคำนวณ</h2>`;
    terminateWorkers(workers); activeWorkers=[]; isCalculating=false; });
}

function cancelAllWorkers() {
  activeWorkers.forEach(worker => worker.terminate());
  activeWorkers = [];
  if (isCalculating) {
    isCalculating = false;
    const elapsed = ((performance.now()-calcStartTime)/1000).toFixed(3);
    if (window.closestResultOnCancel) {
      const EXACT_EPS = 1e-12;
      if (Math.abs(window.closestResultOnCancel.diff) <= EXACT_EPS) {
        document.getElementById("results").innerHTML = `
          <h2>การคำนวณถูกยกเลิก</h2>
          ${renderElapsed(elapsed)}
          <h3>พบคำตอบที่ตรงเป๊ะ:</h3>
          <ul><li>${prettyPrintExpression(window.closestResultOnCancel.expression)} = ${formatNumber(window.closestResultOnCancel.result)}</li></ul>`;
      } else {
        document.getElementById("results").innerHTML = `
          <h2>การคำนวณถูกยกเลิก</h2>
          ${renderElapsed(elapsed)}
          <h3>คำตอบที่ใกล้เคียงที่สุด:</h3>
          <ul><li>${prettyPrintExpression(window.closestResultOnCancel.expression)} = ${formatNumber(window.closestResultOnCancel.result)} (ห่างจากเป้าหมาย ${formatNumber(window.closestResultOnCancel.diff)})</li></ul>`;
      }
    } else {
      document.getElementById("results").innerHTML = `<h2>การคำนวณถูกยกเลิก: ไม่พบคำตอบใดๆ</h2>${renderElapsed(elapsed)}`;
    }
  }
}

function findAllSolutionsParallel(nums, target) {
  const permutations = permute(nums);
  const totalPerms = permutations.length;
  if (totalPerms === 0) { document.getElementById("results").innerHTML = "<h2>ไม่พบคำตอบใดๆ</h2>"; isCalculating = false; return; }
  const numWorkers = navigator.hardwareConcurrency || 4;
  calculationCache.clear(); expressionCache.clear();
  activeWorkers.forEach(w=>w.terminate()); activeWorkers=[];

  let results = []; let expressionSet = new Set();
  let closestResult = null; let smallestDiff = Infinity;
  let nextIndex = 0; // next permutation index to assign
  let baseBatchSize = 4; // starting batch size (perms per assignment)
  const maxBatchSize = 64;
  let completedPerms = 0; // fully processed permutations
  const inProgress = new Map(); // worker -> processed inside its current batch
  let workersFinished = 0; // workers that became idle after queue drained
  const EXACT_EPS = 1e-12;
  let lastUIUpdate = 0;

  document.getElementById("results").innerHTML = `
    <h2>กำลังคำนวณ... 0% (0/${totalPerms})</h2>
    <p>ผลลัพธ์ที่ใกล้เคียงที่สุด: ยังไม่พบ</p>
    <button id="cancel-calc-btn" onclick="cancelCalculation = true; cancelAllWorkers();">ยกเลิกการคำนวณ</button>
  `;

  function adaptiveBatchSize(){
    // Simple growth: enlarge when >50% queue remaining processed quickly
    if (baseBatchSize < maxBatchSize) baseBatchSize = Math.min(maxBatchSize, baseBatchSize * 2);
  }

  function aggregateProcessed(){
    // เดิม: รวมค่าทั้งหมดตรงๆ ซึ่งถ้า inProgress มี NaN จะกลายเป็น NaN ทั้งก้อน
    // ปรับ: ข้ามค่าที่ไม่เป็นตัวเลขหรือไม่ finite เพื่อกัน NaN% ใน UI
    let inProgSum = 0; inProgress.forEach(v=> { if(Number.isFinite(v)) inProgSum += v; });
    return completedPerms + inProgSum;
  }

  function updateUI(force=false){
    const now = performance.now(); if(!force && now - lastUIUpdate < 80) return; lastUIUpdate = now;
    const processed = aggregateProcessed();
    const safeProcessed = Number.isFinite(processed)? processed : completedPerms; // กัน NaN ตกค้าง
    const percent = totalPerms>0 ? Math.round((safeProcessed/totalPerms)*100) : 0;
    let closestText = "ยังไม่พบ";
    if (closestResult){
      if (Math.abs(closestResult.diff) <= EXACT_EPS) closestText = `${prettyPrintExpression(closestResult.expression)} = ${formatNumber(closestResult.result)} (ตรงเป๊ะ)`;
      else closestText = `${prettyPrintExpression(closestResult.expression)} = ${formatNumber(closestResult.result)} (ห่างจากเป้าหมาย ${formatNumber(closestResult.diff)})`;
    }
    document.getElementById("results").innerHTML = `
      <h2>กำลังคำนวณ... ${percent}% (${safeProcessed}/${totalPerms})</h2>
      <p>ผลลัพธ์ที่ใกล้เคียงที่สุด: ${closestText}</p>
      <button id="cancel-calc-btn" onclick="cancelCalculation = true; cancelAllWorkers();">ยกเลิกการคำนวณ</button>
    `;
  }

  function finalizeIfDone(){
    if (completedPerms >= totalPerms && inProgress.size===0){
      const elapsed = ((performance.now()-calcStartTime)/1000).toFixed(3);
      // all permutations processed
      if (results.length > 0){ displayResults(results, elapsed); }
      else if (closestResult){
        if (Math.abs(closestResult.diff) <= EXACT_EPS){
          document.getElementById("results").innerHTML = `
            <h2>พบคำตอบที่ตรงเป๊ะ:</h2>
            ${renderElapsed(elapsed)}
            <ul><li>${prettyPrintExpression(closestResult.expression)} = ${formatNumber(closestResult.result)}</li></ul>`;
        } else {
          const diff = Math.abs(closestResult.result - target).toPrecision(8);
          document.getElementById("results").innerHTML = `
            <h2>คำตอบที่ใกล้เคียงที่สุด:</h2>
            ${renderElapsed(elapsed)}
            <ul><li>${prettyPrintExpression(closestResult.expression)} = ${formatNumber(closestResult.result)} (ห่างจากเป้าหมาย ${diff})</li></ul>`;
        }
      } else {
        document.getElementById("results").innerHTML = `<h2>ไม่พบคำตอบที่ใช้ตัวเลขทั้งหมด</h2>${renderElapsed(elapsed)}`;
      }
      activeWorkers.forEach(w=>w.terminate()); activeWorkers=[]; isCalculating=false; return true;
    }
    return false;
  }

  function assignBatch(worker){
    if (cancelCalculation) return; if (nextIndex >= totalPerms){ return; }
    const start = nextIndex; const size = Math.min(baseBatchSize, totalPerms - nextIndex); const end = start + size; nextIndex = end; inProgress.set(worker,0); worker._batchStart=start; worker._batchEnd=end; worker.postMessage({ type:'findAllRange', permutations, start, end, target, nums, operatorFlags, useIntegerMode, MAX_SQRT_DEPTH, MAX_FACT_DEPTH, MAX_LOG_DEPTH, MAX_LN_DEPTH, MAX_FACTORIAL_INPUT, MAX_RESULTS: Infinity });
    if (nextIndex < totalPerms) adaptiveBatchSize();
  }

  for(let w=0; w<numWorkers; w++){
    const worker = new Worker('worker.js'); activeWorkers.push(worker);
    worker.onmessage = function(e){ if(cancelCalculation) return; const data=e.data;
      if (data.progress){
        // ป้องกัน NaN: ตั้งค่าเฉพาะเมื่อมีตัวเลข processed ส่งมาจริง
        if (typeof data.processed === 'number' && Number.isFinite(data.processed)) {
          inProgress.set(worker, Math.min(data.processed, (worker._batchEnd - worker._batchStart)));
        }
        if (data.closest && (!closestResult || data.closest.diff < smallestDiff)) { smallestDiff=data.closest.diff; closestResult=data.closest; window.closestResultOnCancel=closestResult; }
        updateUI();
        return;
      }
      if (data.results){
        data.results.forEach(res=>{ if(!expressionSet.has(res.expression)){ expressionSet.add(res.expression); results.push(res);} });
      }
      if (data.closest && (!closestResult || data.closest.diff < smallestDiff)) { smallestDiff=data.closest.diff; closestResult=data.closest; window.closestResultOnCancel=closestResult; }
      // batch finished
      const batchSize = (worker._batchEnd - worker._batchStart);
      completedPerms += batchSize; inProgress.delete(worker); updateUI(true);
      if (finalizeIfDone()) return;
      assignBatch(worker);
      if (nextIndex >= totalPerms && !inProgress.has(worker)){ // no more work assigned to this worker
        workersFinished++;
      }
    };
    worker.onerror = function(){ inProgress.delete(worker); completedPerms += (worker._batchEnd - worker._batchStart)||0; updateUI(true); if(!finalizeIfDone()) assignBatch(worker); };
    assignBatch(worker);
  }
}

function permute(arr) {
  const seen = new Set();
  const permutations = [];
  const c = new Array(arr.length).fill(0);
  let i = 1;
  const initial = arr.slice();
  const key = initial.join(",");
  seen.add(key);
  permutations.push(initial);
  while (i < arr.length) {
    if (c[i] < i) {
      const swapIndex = i % 2 ? c[i] : 0;
      [arr[swapIndex], arr[i]] = [arr[i], arr[swapIndex]];
      const key = arr.join(",");
      if (!seen.has(key)) {
        seen.add(key);
        permutations.push(arr.slice());
      }
      c[i]++;
      i = 1;
    } else {
      c[i] = 0;
      i++;
    }
  }
  return permutations;
}

function terminateWorkers(workers) {
  workers.forEach(worker => worker.terminate());
}

function usesAllNumbers(ast, originalNums) {
  const numbers = [];
  function extractNumbers(node) {
    if (node.type === "num") numbers.push(node.value);
    if (node.left) extractNumbers(node.left);
    if (node.right) extractNumbers(node.right);
  }
  extractNumbers(ast);
  if (numbers.length !== originalNums.length) return false;
  const sortedUsed = [...numbers].sort((a, b) => a - b);
  const sortedOriginal = [...originalNums].sort((a, b) => a - b);
  const EPS = 1e-9;
  for (let i = 0; i < sortedUsed.length; i++) {
    if (Math.abs(sortedUsed[i] - sortedOriginal[i]) > EPS) return false;
  }
  return true;
}

function respectsLockOrder(ast, originalNums, lockedIndices) {
  const numberPositions = [];
  function extractPositions(node, position = []) {
    if (node.type === "num") numberPositions.push({ value: node.value, position: [...position] });
    if (node.left) extractPositions(node.left, [...position, 'left']);
    if (node.right) extractPositions(node.right, [...position, 'right']);
  }
  extractPositions(ast);
  const originalPositions = new Map();
  originalNums.forEach((num, index) => originalPositions.set(index, num));
  for (const lockedIndex of lockedIndices) {
    const lockedNum = originalNums[lockedIndex];
    const lockedPosInAST = numberPositions.find(np => np.value === lockedNum);
    if (!lockedPosInAST) return false;
    const allPositions = numberPositions.map(np => np.position.length);
    const maxDepth = Math.max(...allPositions);
    const lockedDepth = lockedPosInAST.position.length;
    if (lockedIndex === originalNums.length - 1) {
      if (lockedDepth !== maxDepth || numberPositions.filter(np => np.position.length === maxDepth).length > 1) return false;
    } else if (lockedIndex === 0) {
      if (lockedDepth !== 0) return false;
    } else {
      const beforeLocked = originalNums.slice(0, lockedIndex);
      const afterLocked = originalNums.slice(lockedIndex + 1);
      const beforeCount = numberPositions.filter(np => beforeLocked.includes(np.value) && np.position.length < lockedDepth).length;
      const afterCount = numberPositions.filter(np => afterLocked.includes(np.value) && np.position.length > lockedDepth).length;
      if (beforeCount !== beforeLocked.length || afterCount !== afterLocked.length) return false;
    }
  }
  return true;
}

function updateProgress(processed, total, target, results, closestResult) {
  const percent = Math.round((processed / total) * 100);
  let closestText = "ยังไม่พบ";
  const EXACT_EPS = 1e-12;
  if (closestResult) {
    if (Math.abs(closestResult.diff) <= EXACT_EPS) {
      closestText = `${prettyPrintExpression(closestResult.expression)} = ${formatNumber(closestResult.result)} (ตรงเป๊ะ)`;
    } else {
      closestText = `${prettyPrintExpression(closestResult.expression)} = ${formatNumber(closestResult.result)} (ห่างจากเป้าหมาย ${formatNumber(closestResult.diff)})`;
    }
  }
  document.getElementById("results").innerHTML = `
    <h2>กำลังคำนวณ... ${percent}% (${processed}/${total})</h2>
    <p>ผลลัพธ์ที่ใกล้เคียงที่สุด: ${closestText}</p>
    <button id="cancel-calc-btn" onclick="cancelCalculation = true; cancelAllWorkers();">ยกเลิกการคำนวณ</button>
  `;
}

function prettyPrintExpression(expr) {
  let s = expr
    .replace(/\( *([^\(\)]+) *\)!/g, '$1!')
    .replace(/√\(([^(\)]+)\)/g, '√$1');
  s = s.replace(/\(([^(\)]+)\s\^\s([^\(\)]+)\)/g, '$1^$2');
  s = s.replace(/\*/g, '×').replace(/\//g, '÷').replace(/%/g, ' mod ');
  // keep || as is, or could replace with ⧺ later
  s = s.replace(/\(([0-9]+)\)/g, '$1');
  // Replace numeric constants with math symbols
  s = s.replace(/2\.718281828459045/g, 'e');
  s = s.replace(/3\.141592653589793/g, 'π');
  // Remove trivial parentheses around constants
  s = s.replace(/\((π|e)\)/g, '$1');
  while (
    s.startsWith('(') &&
    s.endsWith(')') &&
    (() => {
      let depth = 0;
      for (let i = 0; i < s.length; ++i) {
        if (s[i] === '(') depth++;
        if (s[i] === ')') depth--;
        if (depth === 0 && i < s.length - 1) return false;
      }
      return depth === 0;
    })()
  ) {
    s = s.slice(1, -1);
  }
  s = s.replace(/\s+/g, ' ').replace(/\( /g, '(').replace(/ \)/g, ')');
  return s;
}

function displayResults(results, elapsedOverride) {
  const elapsed = elapsedOverride || ((performance.now()-calcStartTime)/1000).toFixed(3);
  if (results.length > 0) {
    if(useCleanMode){
      function computeCleanScore(expr){
        const protectedExpr = expr.replace(/\|\|/g,'§').replace(/log(?=\()/g,'Ł').replace(/ln(?=\()/g,'ŀ');
        const ops = protectedExpr.match(/[+\-*\/^%√!§∑Łŀ]/g) || [];
        const opCount = ops.length;
        const parenCount = (expr.match(/\(/g)||[]).length;
        const weightMap = { '+':1, '-':1, '*':2, '/':2, '%':3, '§':5, '^':3, '√':4, '!':4, '∑':5, 'Ł':4, 'ŀ':4 };
  let sumWeight=0;
  ops.forEach(o=>{ const w=weightMap[o]||9; sumWeight+=w; });
  return { sumWeight, opCount, parenCount, length: expr.length };
      }
      function betterScore(a,b){
        if(a.sumWeight!==b.sumWeight) return a.sumWeight - b.sumWeight;
        if(a.opCount!==b.opCount) return a.opCount - b.opCount;
        if(a.parenCount!==b.parenCount) return a.parenCount - b.parenCount;
        return a.length - b.length;
      }
      let best = null; let bestScore=null;
      for(const r of results){
        const sc = computeCleanScore(r.expression);
        if(!best || betterScore(sc,bestScore)<0){ best=r; bestScore=sc; }
      }
      if(best){
        document.getElementById("results").innerHTML = `
          <h2>ผลลัพธ์ที่คลีนที่สุด (จาก ${results.length} แบบ)</h2>
          ${renderElapsed(elapsed)}
          <ul><li>${prettyPrintExpression(best.expression)} = ${formatNumber(best.result)}</li></ul>`;
        return;
      }
    }
    document.getElementById("results").innerHTML =
      `<h2>ผลลัพธ์ (${results.length} รายการ)</h2>${renderElapsed(elapsed)}<ul>` +
      results.map((res) => `<li>${prettyPrintExpression(res.expression)} = ${formatNumber(res.result)}</li>`).join("") +
      `</ul>`;
  } else if (window.closestResultOnCancel) {
    const target = parseFloat(document.getElementById("target").value);
    const EXACT_EPS = 1e-12;
    const diffRaw = Math.abs(window.closestResultOnCancel.result - target);
    if (diffRaw <= EXACT_EPS) {
      document.getElementById("results").innerHTML = `
        <h2>พบคำตอบที่ตรงเป๊ะ:</h2>
        ${renderElapsed(elapsed)}
        <ul><li>${prettyPrintExpression(window.closestResultOnCancel.expression)} = ${formatNumber(window.closestResultOnCancel.result)}</li></ul>`;
    } else {
      const diff = diffRaw.toPrecision(8);
      document.getElementById("results").innerHTML = `
        <h2>คำตอบที่ใกล้เคียงที่สุด:</h2>
        ${renderElapsed(elapsed)}
        <ul><li>${prettyPrintExpression(window.closestResultOnCancel.expression)} = ${formatNumber(window.closestResultOnCancel.result)} (ห่างจากเป้าหมาย ${diff})</li></ul>`;
    }
  } else {
    document.getElementById("results").innerHTML = `<h2>ไม่พบคำตอบที่ใช้ตัวเลขทั้งหมด</h2>${renderElapsed(elapsed)}`;
  }
}

// NEW helper to render elapsed time snippet at top
function renderElapsed(seconds){
  return `<div class="elapsed-time" style="margin:4px 0 10px; font-size:0.85rem; opacity:0.85;">เวลาใช้ไป: ${seconds} วินาที</div>`;
}

// Initialize
addNumber();
// Ensure initial input supports decimals
const firstNum = document.querySelector('.num');
if (firstNum) firstNum.step = 'any';


// Initialize WASM status
initializeWASM();

// Set initial button states
document.getElementById("toggleAddBtn").textContent = "ปิดการใช้ +";
document.getElementById("toggleSubBtn").textContent = "ปิดการใช้ -";
document.getElementById("toggleMulBtn").textContent = "ปิดการใช้ ×";
document.getElementById("toggleDivBtn").textContent = "ปิดการใช้ ÷";

// Replace with simple non-drag navigation for stability on touch devices
function initNavSwitch(){
  const buttons = document.querySelectorAll('.nav-glass-switch .nav-btn');
  buttons.forEach(btn=>{
    // Ensure single activation logic
    btn.addEventListener('click', ()=> showPage(btn.dataset.target, btn));
    // Explicit touchstart for iOS (prevent 300ms delay / ghost double-trigger)
    btn.addEventListener('touchstart', (e)=>{ e.preventDefault(); showPage(btn.dataset.target, btn); }, {passive:false});
  });
  // Initial blob positioning
  requestAnimationFrame(updateNavBlob);
}
window.addEventListener('load', initNavSwitch);

// Improved drag logic (re-instated with simpler reliable implementation for iPad / desktop)
function initNavDrag(){
  const switchEl = document.querySelector('.nav-glass-switch');
  if(!switchEl) return;
  const blob = switchEl.querySelector('.nav-blob');
  const buttons = Array.from(switchEl.querySelectorAll('.nav-btn'));
  let activeIndex = buttons.findIndex(b=>b.classList.contains('active'));
  if(activeIndex < 0) activeIndex = 0;
  // Helper to snap blob to active button
  function snapToActive(animate=true){
    const btn = buttons[activeIndex];
    if(!btn) return;
    const rect = btn.getBoundingClientRect();
    const parentRect = switchEl.getBoundingClientRect();
    const left = rect.left - parentRect.left;
    blob.style.width = rect.width + 'px';
    if(!animate){
      switchEl.classList.add('dragging');
      blob.style.setProperty('--blob-x', left + 'px');
      switchEl.offsetHeight; // force layout
      switchEl.classList.remove('dragging');
    } else {
      blob.style.setProperty('--blob-x', left + 'px');
    }
  }
  snapToActive(false);
  // Click / tap activation
  buttons.forEach((btn,i)=>{
    btn.dataset.index = i;
    btn.addEventListener('click', ()=>{ activeIndex=i; showPage(btn.dataset.target, btn); snapToActive(true); });
    btn.addEventListener('touchstart', (e)=>{ e.preventDefault(); activeIndex=i; showPage(btn.dataset.target, btn); snapToActive(true); }, {passive:false});
  });
  // Drag state
  let dragging = false; let startX = 0; let originX = 0; let maxX = 0;
  function pointerDown(e){
    if(e.type==='mousedown' && e.button!==0) return;
    if(!switchEl.contains(e.target)) return;
    dragging = true; window.navDragging = true; switchEl.classList.add('dragging');
    const parentRect = switchEl.getBoundingClientRect();
    const activeBtn = buttons[activeIndex];
    const btnRect = activeBtn.getBoundingClientRect();
    originX = btnRect.left - parentRect.left;
    startX = e.touches ? e.touches[0].clientX : e.clientX;
    blob.style.width = btnRect.width + 'px';
    maxX = parentRect.width - btnRect.width - 8; // padding safeguard
    e.preventDefault();
  }
  function pointerMove(e){
    if(!dragging) return;
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    let x = originX + (clientX - startX);
    if(x < 0) x = 0; if(x > maxX) x = maxX;
    blob.style.setProperty('--blob-x', x + 'px');
    // Determine nearest button
    const parentRect = switchEl.getBoundingClientRect();
    const center = x + blob.offsetWidth/2;
    let nearest = activeIndex; let best = Infinity;
    buttons.forEach((btn,i)=>{
      const r = btn.getBoundingClientRect();
      const c = r.left - parentRect.left + r.width/2;
      const d = Math.abs(c - center);
      if(d < best){ best = d; nearest = i; }
    });
    activeIndex = nearest;
    e.preventDefault();
  }
  function pointerUp(e){
    if(!dragging) return;
    dragging = false; window.navDragging = false; switchEl.classList.remove('dragging');
    const btn = buttons[activeIndex];
    if(btn){ showPage(btn.dataset.target, btn); }
    snapToActive(true);
    e.preventDefault();
  }
  // Event listeners
  ['pointerdown','mousedown','touchstart'].forEach(ev=> switchEl.addEventListener(ev, pointerDown, {passive:false}));
  ['pointermove','mousemove','touchmove'].forEach(ev=> window.addEventListener(ev, pointerMove, {passive:false}));
  ['pointerup','mouseup','touchend','touchcancel','mouseleave'].forEach(ev=> window.addEventListener(ev, pointerUp, {passive:false}));
  window.addEventListener('resize', ()=>{ if(!dragging) snapToActive(true); });
}
window.addEventListener('load', initNavDrag);
    </script>
</body>
</html>