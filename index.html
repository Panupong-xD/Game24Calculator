<!DOCTYPE html>
<html lang="th">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ตัวเลขและผลลัพธ์ที่เป็นไปได้</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <!-- Navigation -->
    <div class="nav-container">
      <!-- New liquid glass segmented control -->
      <div class="nav-glass-switch">
        <div class="nav-blob"></div>
        <button class="nav-btn nav-tab active" onclick="showPage('calculation-page', this);" data-target="calculation-page">การคำนวณ</button>
        <button class="nav-btn nav-tab" onclick="showPage('settings-page', this);" data-target="settings-page">การตั้งค่า</button>
      </div>
      <div class="theme-toggle" onclick="toggleTheme()"></div>
    </div>

    <!-- Main Content -->
    <div class="main-container">
      <!-- Calculation Page -->
      <div id="calculation-page" class="page active">
        <div class="container">
          <h1>คำนวณผลลัพธ์ที่เป็นไปได้</h1>
          <p>กรอกตัวเลขและผลลัพธ์ที่ต้องการคำนวณ</p>
          <div id="numbers" class="number-container"></div>
          <button class="add-btn" onclick="addNumber()">+</button>
          <button class="remove-btn" onclick="removeNumber()">-</button>
          <br />
          <input
            type="number"
            id="target"
            placeholder="ผลลัพธ์"
            class="easy-input"
            step="any"
          />
          <br />
          <button class="calc-btn" onclick="findSolutions()">ค้นหาคำตอบ</button>
          <div id="results"></div>
        </div>
      </div>

      <!-- Updated Settings Page -->
      <div id="settings-page" class="page">
        <div class="container">
          <h1>การตั้งค่า</h1>
          <p>ปรับแต่งการทำงานของเครื่องมือคำนวณ</p>
          
          <div class="settings-options">
            <div class="option-group">
              <h3>ตัวเลือกการคำนวณ</h3>
              <div class="operator-buttons">
                <!-- Replace * and / visible text with × and ÷ -->
                <button id="toggleAddBtn" class="toggle-btn" onclick="toggleOperator('+')">เปิดการใช้ +</button>
                <button id="toggleSubBtn" class="toggle-btn" onclick="toggleOperator('-')">เปิดการใช้ -</button>
                <button id="toggleMulBtn" class="toggle-btn" onclick="toggleOperator('*')">เปิดการใช้ ×</button>
                <button id="toggleDivBtn" class="toggle-btn" onclick="toggleOperator('/')">เปิดการใช้ ÷</button>
                <button id="toggleModBtn" class="toggle-btn" onclick="toggleOperator('%')">เปิดการใช้ mod</button>
                <button id="togglePowBtn" class="toggle-btn" onclick="toggleOperator('^')">เปิดการใช้ ^</button>
                <button id="toggleSqrtBtn" class="toggle-btn" onclick="toggleOperator('√')">เปิดการใช้ √</button>
                <div id="sqrt-depth-container" class="sqrt-depth-container">
                  <label for="sqrt-depth">ระดับการซ้อน √ สูงสุด: </label>
                  <input
                    type="number"
                    id="sqrt-depth"
                    class="sqrt-depth-input"
                    min="1"
                    value="2"
                    onchange="updateMaxSqrtDepth()"
                  />
                </div>
                <button id="toggleFactBtn" class="toggle-btn" onclick="toggleOperator('!')">เปิดการใช้ !</button>
                <div id="fact-depth-container" class="fact-depth-container" style="display:none;">
                  <label for="fact-depth">ระดับการซ้อน ! สูงสุด: </label>
                  <input
                    type="number"
                    id="fact-depth"
                    class="fact-depth-input"
                    min="1"
                    value="1"
                    onchange="updateMaxFactDepth()"
                  />
                </div>
              </div>
              <button id="toggleFastModeBtn" onclick="toggleFastMode()" class="toggle-btn mode-btn">เปิดโหมดหาคำตอบเร็ว</button>
              <div id="fast-accuracy-container" class="fast-accuracy-container" style="display:none; margin-top:8px;">
                <label for="fast-accuracy-slider" style="display:block; font-size:0.9rem; margin-bottom:4px;">ปรับสมดุล: ความเร็ว ←→ ความแม่น</label>
                <input type="range" id="fast-accuracy-slider" min="0" max="100" value="60" oninput="updateFastAccuracyLabel()" />
                <div id="fast-accuracy-label" style="font-size:0.8rem; margin-top:2px; opacity:0.8;">สมดุล (60)</div>
              </div>
              <button id="toggleIntegerModeBtn" onclick="toggleIntegerMode()" class="toggle-btn mode-btn">เปิดโหมดจำนวนเต็ม</button>
            </div>
            
            <div class="option-group">
              <h3>สถานะระบบ</h3>
              <div id="wasm-status" class="status-indicator">
                <span id="wasm-status-text">กำลังโหลด WebAssembly...</span>
                <div id="wasm-status-icon" class="status-icon loading"></div>
              </div>
              <p class="status-description">WebAssembly เพิ่มความเร็วในการคำนวณทางคณิตศาสตร์</p>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- JavaScript -->
    <script src="wasm-math.js"></script>
    <script>
// Page Navigation (refactored to avoid reliance on global event)
function showPage(pageId, sourceBtn=null) {
  // switch page visibility
  document.querySelectorAll('.page').forEach(p=>p.classList.remove('active'));
  const pageEl = document.getElementById(pageId);
  if(pageEl) pageEl.classList.add('active');
  // update active nav button
  const buttons = document.querySelectorAll('.nav-glass-switch .nav-btn');
  buttons.forEach(btn=>btn.classList.remove('active'));
  let targetBtn = sourceBtn || document.querySelector(`.nav-glass-switch .nav-btn[data-target="${pageId}"]`);
  if(targetBtn) targetBtn.classList.add('active');
  // sync blob position after layout
  requestAnimationFrame(()=> updateNavBlob());
}

// Core variables
let operatorFlags = { '+': true, '-': true, '*': true, '/': true, '%': false, '^': false, '√': false, '!': false };
let useFastMode = false;
let useIntegerMode = false;
// Added: speed-accuracy tuning (0=สุดเร็ว,1=สุดแม่น)
let fastAccuracy = 0.60; // default bias to slightly accuracy
let isCalculating = false;
let cancelCalculation = false;
let activeWorkers = [];
let MAX_SQRT_DEPTH = 2;
let MAX_FACT_DEPTH = 1;
const MAX_FACTORIAL_INPUT = 12;
const MAX_RESULTS = 100;
const CHUNK_SIZE = 20;

const factorialCache = new Map();
const calculationCache = new Map();
const expressionCache = new Map();

// UI Control Functions
document.body.classList.add('light-theme');

function toggleTheme() {
  document.body.classList.toggle('light-theme');
  document.body.classList.toggle('dark-theme');
  // ensure blob still aligned after theme transition
  setTimeout(updateNavBlob, 300);
}

function displayOperatorLabel(op){
  if(op==='*') return '×';
  if(op=== '/') return '÷';
  if(op=== '%') return 'mod';
  return op;
}

function toggleOperator(op) {
  operatorFlags[op] = !operatorFlags[op];
  const btn = document.getElementById(`toggle${op === '+' ? 'Add' : op === '-' ? 'Sub' : op === '*' ? 'Mul' : op === '/' ? 'Div' : op === '%' ? 'Mod' : op === '^' ? 'Pow' : op === '√' ? 'Sqrt' : 'Fact'}Btn`);
  const disp = displayOperatorLabel(op);
  if (operatorFlags[op]) {
    btn.textContent = `ปิดการใช้ ${disp}`;
    btn.classList.add('active');
    if (op === '√') document.getElementById("sqrt-depth-container").classList.add("active");
    if (op === '!') document.getElementById("fact-depth-container").style.display = "block";
  } else {
    btn.textContent = `เปิดการใช้ ${disp}`;
    btn.classList.remove('active');
    if (op === '√') document.getElementById("sqrt-depth-container").classList.remove("active");
    if (op === '!') document.getElementById("fact-depth-container").style.display = "none";
  }
}

document.getElementById("toggleAddBtn").classList.add('active');
document.getElementById("toggleSubBtn").classList.add('active');
document.getElementById("toggleMulBtn").classList.add('active');
document.getElementById("toggleDivBtn").classList.add('active');

function updateNavBlob(){
  const switchEl = document.querySelector('.nav-glass-switch');
  const blob = switchEl?.querySelector('.nav-blob');
  const active = switchEl?.querySelector('.nav-btn.active');
  if(!blob || !active || !switchEl) return;
  const rect = active.getBoundingClientRect();
  const parentRect = switchEl.getBoundingClientRect();
  const left = rect.left - parentRect.left;
  if(typeof window.prevBlobLeft === 'undefined') window.prevBlobLeft = left;
  const delta = left - window.prevBlobLeft;
  const adelta = Math.abs(delta);
  blob.classList.remove('squish-light','squish-medium','squish-strong');
  if(adelta > 60) blob.classList.add('squish-strong');
  else if(adelta > 25) blob.classList.add('squish-medium');
  else blob.classList.add('squish-light');
  blob.style.width = rect.width + 'px';
  blob.style.setProperty('--blob-x', left + 'px');
  window.prevBlobLeft = left;
}

window.addEventListener('resize', ()=> requestAnimationFrame(updateNavBlob));
window.addEventListener('orientationchange', ()=> setTimeout(updateNavBlob,150));
window.addEventListener('load', ()=> setTimeout(updateNavBlob,50));

function toggleFastMode() {
  useFastMode = !useFastMode;
  const btn = document.getElementById("toggleFastModeBtn");
  const container = document.getElementById('fast-accuracy-container');
  if (useFastMode) {
    btn.textContent = "ปิดโหมดหาคำตอบเร็ว";
    btn.classList.add('active-mode');
    container.style.display = 'block';
  } else {
    btn.textContent = "เปิดโหมดหาคำตอบเร็ว";
    btn.classList.remove('active-mode');
    container.style.display = 'none';
  }
}
function updateFastAccuracyLabel(){
  const slider = document.getElementById('fast-accuracy-slider');
  if(!slider) return;
  fastAccuracy = slider.value/100; // 0..1
  // sync filled gradient length
  slider.style.setProperty('--progress', fastAccuracy.toString());
  let txt;
  if(fastAccuracy < 0.15) txt='เร็วที่สุด';
  else if(fastAccuracy < 0.35) txt='เร็วมาก';
  else if(fastAccuracy < 0.55) txt='ค่อนข้างเร็ว';
  else if(fastAccuracy < 0.70) txt='สมดุล';
  else if(fastAccuracy < 0.85) txt='ค่อนข้างแม่น';
  else if(fastAccuracy < 0.95) txt='แม่นมาก';
  else txt='แม่นสูงสุด';
  document.getElementById('fast-accuracy-label').textContent = `${txt} (${slider.value})`;
}
// init label once
updateFastAccuracyLabel();

(function(){
  const slider = document.getElementById('fast-accuracy-slider');
  if(!slider) return;

  const isiOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform==='MacIntel' && navigator.maxTouchPoints>1);

  // Internal state
  let isDown = false; let lastX=null; let lastT=null; let velocity=0; let rafDecay=null; let frame=null;
  const MAX_ABS_V = 3200; // clamp
  const MIN_ABS_V = 18;
  const BASE_STRETCH = 0.24; // magnitude scaling
  const DECAY = 0.88; // velocity decay per frame
  let recoilAnimating=false, recoilStart=0; const RECOIL_MS=380;

  function setVar(name,val){ slider.style.setProperty(name,val); }
  function startRecoil(){
    recoilAnimating=true; recoilStart=performance.now();
    // initial overshoot (tall & narrow)
    setVar('--recoil-x','0.78');
    setVar('--recoil-y','1.22');
    requestAnimationFrame(stepRecoil);
  }
  function stepRecoil(){
    if(!recoilAnimating) return;
    const now=performance.now();
    const t=Math.min(1,(now-recoilStart)/RECOIL_MS);
    // ease out elastic-ish
    // custom curve: blend of easeOutCubic and small damping oscillation
    const ease = 1 - Math.pow(1-t,3);
    // damp oscillation factor
    const osc = Math.sin(t*3.4*Math.PI) * (1-t)*0.12;
    const targetX = 1; const startX=0.78; const currentX = startX + (targetX-startX)*ease + osc;
    const targetY = 1; const startY=1.22; const currentY = startY + (targetY-startY)*ease - osc*0.85;
    setVar('--recoil-x', currentX.toFixed(4));
    setVar('--recoil-y', currentY.toFixed(4));
    if(t>=1){ recoilAnimating=false; setVar('--recoil-x','1'); setVar('--recoil-y','1'); return; }
    requestAnimationFrame(stepRecoil);
  }

  function press(){ slider.classList.remove('glass-release'); slider.offsetHeight; slider.classList.add('glass-press'); }
  function release(){ slider.classList.remove('glass-press'); slider.classList.add('glass-release'); startRecoil(); }

  function getClientX(e){ return e.touches? e.touches[0].clientX : e.clientX; }

  function pointerDown(e){ if(isDown) return; isDown=true; lastX=getClientX(e); lastT=performance.now(); velocity=0; if(rafDecay) cancelAnimationFrame(rafDecay); rafDecay=null; press(); }
  function pointerMove(e){ if(!isDown) return; const now=performance.now(); const x=getClientX(e); const dt=(now-lastT)/1000; if(lastX!=null && dt>0){ const dx=x-lastX; velocity = dx/dt; applyStretch(velocity); } lastX=x; lastT=now; }
  function pointerUp(){ if(!isDown) return; isDown=false; release(); if(rafDecay) cancelAnimationFrame(rafDecay); rafDecay=requestAnimationFrame(decay); }

  // Update progress custom property for blue tube (since native range won't update our gradient automatically in all engines)
  function syncProgress(){ const val=parseFloat(slider.value||0); const min=parseFloat(slider.min||0); const max=parseFloat(slider.max||100); const ratio=(val-min)/(max-min); setVar('--progress', ratio.toString()); }
  slider.addEventListener('input', syncProgress, {passive:true});
  syncProgress();

  // Events (support pointer + touch + mouse)
  slider.addEventListener('pointerdown', pointerDown, {passive:true});
  slider.addEventListener('touchstart', pointerDown, {passive:true});
  slider.addEventListener('mousedown', pointerDown, {passive:true});

  window.addEventListener('pointermove', pointerMove, {passive:true});
  window.addEventListener('touchmove', pointerMove, {passive:true});
  window.addEventListener('mousemove', pointerMove, {passive:true});

  window.addEventListener('pointerup', pointerUp, {passive:true});
  window.addEventListener('touchend', pointerUp, {passive:true});
  window.addEventListener('mouseup', pointerUp, {passive:true});
  window.addEventListener('touchcancel', pointerUp, {passive:true});

  // iOS direct transform fallback if CSS var scaling jank detected
  if(isiOS){
    // Attempt heuristic: adapt transforms via style injection each frame (here our slider thumb isn't a direct element we can easily select; for WebKit we rely on pseudo element). We'll keep CSS variable method; Safari 16+ handles it. If needed, future enhancement could use overlay custom thumb.
  }
})();

function toggleIntegerMode() {
  useIntegerMode = !useIntegerMode;
  const btn = document.getElementById("toggleIntegerModeBtn");
  if (useIntegerMode) {
    btn.textContent = "ปิดโหมดจำนวนเต็ม";
    btn.classList.add('active-mode');
  } else {
    btn.textContent = "เปิดโหมดจำนวนเต็ม";
    btn.classList.remove('active-mode');
  }
}

function updateMaxSqrtDepth() {
  const input = document.getElementById("sqrt-depth");
  const value = parseInt(input.value);
  if (!isNaN(value) && value >= 1) MAX_SQRT_DEPTH = value;
  else input.value = MAX_SQRT_DEPTH;
}

function updateMaxFactDepth() {
  const input = document.getElementById("fact-depth");
  const value = parseInt(input.value);
  if (!isNaN(value) && value >= 1) MAX_FACT_DEPTH = value;
  else input.value = MAX_FACT_DEPTH;
}

function addNumber() {
  let numbers = document.querySelectorAll(".num-container");
  if (numbers.length < 8) {
    let div = document.createElement("div");
    div.className = "num-container";
    let input = document.createElement("input");
    input.type = "number";
    input.className = "num";
    input.placeholder = "0";
    input.step = "any"; // allow decimals
    div.appendChild(input);
    document.getElementById("numbers").appendChild(div);
  }
}

function removeNumber() {
  let numbers = document.getElementById("numbers");
  if (numbers.children.length > 1) numbers.removeChild(numbers.lastChild);
}

// Basic Calculation Functions
function factorial(n) {
  if (n < 0 || n > MAX_FACTORIAL_INPUT || !Number.isInteger(n)) return NaN;
  if (n === 0 || n === 1) return 1;
  if (factorialCache.has(n)) return factorialCache.get(n);
  
  // Use WebAssembly if available
  let result;
  if (window.wasmMath && window.wasmMath.isReady) {
    result = window.wasmMath.factorial(n);
  } else {
    // JavaScript fallback
    result = 1;
    for (let i = 2; i <= n; i++) result *= i;
  }
  
  factorialCache.set(n, result);
  return result;
}

function evaluateAST(node) {
  if (node.type === "num") return node.value;
  let leftVal = node.left ? evaluateAST(node.left) : null;
  let rightVal = evaluateAST(node.right);
  const cacheKey = `${node.operator}|${leftVal}|${rightVal}`;
  if (calculationCache.has(cacheKey)) return calculationCache.get(cacheKey);
  
  let result;
  
  // Use WebAssembly for basic operations when available
  if (window.wasmMath && window.wasmMath.isReady) {
    switch (node.operator) {
      case "+": 
        result = operatorFlags['+'] ? window.wasmMath.add(leftVal, rightVal) : NaN; 
        break;
      case "-": 
        result = operatorFlags['-'] ? window.wasmMath.sub(leftVal, rightVal) : NaN; 
        break;
      case "*": 
        result = operatorFlags['*'] ? window.wasmMath.mul(leftVal, rightVal) : NaN; 
        break;
      case "/": 
        result = operatorFlags['/'] && rightVal !== 0 ? window.wasmMath.div(leftVal, rightVal) : NaN; 
        break;
      case "%":
        if (!operatorFlags['%'] || rightVal === 0) return NaN;
        result = leftVal - rightVal * Math.floor(leftVal / rightVal);
        break;
      case "^":
        if (!operatorFlags['^']) return NaN;
        result = (leftVal === 0 && rightVal <= 0) ? (rightVal === 0 ? 1 : NaN) : window.wasmMath.pow(leftVal, rightVal);
        break;
      case "√": 
        result = operatorFlags['√'] && rightVal >= 0 ? window.wasmMath.sqrt(rightVal) : NaN; 
        break;
      case "!": 
        result = operatorFlags['!'] && rightVal <= MAX_FACTORIAL_INPUT && rightVal >= 0 && Number.isInteger(rightVal) ? window.wasmMath.factorial(rightVal) : NaN; 
        break;
      default: return NaN;
    }
  } else {
    // JavaScript fallback
    switch (node.operator) {
      case "+": result = operatorFlags['+'] ? leftVal + rightVal : NaN; break;
      case "-": result = operatorFlags['-'] ? leftVal - rightVal : NaN; break;
      case "*": result = operatorFlags['*'] ? leftVal * rightVal : NaN; break;
      case "/": result = operatorFlags['/'] && rightVal !== 0 ? leftVal / rightVal : NaN; break;
      case "%":
        if (!operatorFlags['%'] || rightVal === 0) return NaN;
        result = leftVal - rightVal * Math.floor(leftVal / rightVal);
        break;
      case "^":
        if (!operatorFlags['^']) return NaN;
        result = (leftVal === 0 && rightVal <= 0) ? (rightVal === 0 ? 1 : NaN) : Math.pow(leftVal, rightVal);
        break;
      case "√": result = operatorFlags['√'] && rightVal >= 0 ? Math.sqrt(rightVal) : NaN; break;
      case "!": result = operatorFlags['!'] && rightVal <= MAX_FACTORIAL_INPUT && rightVal >= 0 && Number.isInteger(rightVal) ? factorial(rightVal) : NaN; break;
      default: return NaN;
    }
  }
  
  if (!isNaN(result)) {
    if (calculationCache.size > 1000000) calculationCache.clear();
    calculationCache.set(cacheKey, result);
  }
  return result;
}

function isIntegerResult(result) {
  return Number.isInteger(result) || Math.abs(result - Math.round(result)) < 0.0001;
}

function serializeAST(node) {
  if (node.type === "num") return node.value.toString();
  if (node.operator === "√") return `√(${serializeAST(node.right)})`;
  if (node.operator === "!") return `(${serializeAST(node.right)})!`;
  return `(${node.left ? serializeAST(node.left) : ""} ${node.operator} ${serializeAST(node.right)})`;
}

function canonicalizeAST(node) {
  if (node.type === "num") return node;
  let left = node.left ? canonicalizeAST(node.left) : null;
  let right = canonicalizeAST(node.right);
  if (node.operator === "+" || node.operator === "*" || node.operator === "%") {
    let leftStr = serializeAST(left);
    let rightStr = serializeAST(right);
    if (leftStr > rightStr) return { type: "op", operator: node.operator, left: right, right: left };
  }
  return { type: "op", operator: node.operator, left, right };
}

function getSqrtDepth(node) {
  if (node.type === "num") return 0;
  if (node.operator === "√") return 1 + getSqrtDepth(node.right);
  let leftDepth = node.left ? getSqrtDepth(node.left) : 0;
  let rightDepth = node.right ? getSqrtDepth(node.right) : 0;
  return Math.max(leftDepth, rightDepth);
}

function getFactDepth(node) {
  if (node.type === "num") return 0;
  if (node.operator === "!") return 1 + getFactDepth(node.right);
  let leftDepth = node.left ? getFactDepth(node.left) : 0;
  let rightDepth = node.right ? getFactDepth(node.right) : 0;
  return Math.max(leftDepth, rightDepth);
}

function generateAllGroupings(nums, target) {
  const memoized = new Map();
  function generateGroupingsHelper(start, end) {
    const key = `${start}-${end}`;
    if (memoized.has(key)) return memoized.get(key);
    const result = [];
    if (start === end) {
      const numNode = { type: "num", value: nums[start] };
      result.push(numNode);
      if (operatorFlags['√'] && nums[start] >= 0 && (!useIntegerMode || Number.isInteger(Math.sqrt(nums[start])))) {
        let currentExpr = numNode;
        for (let i = 1; i <= MAX_SQRT_DEPTH && operatorFlags['√']; i++) {
          currentExpr = { type: "op", operator: "√", left: null, right: currentExpr };
          const sqrtResult = evaluateAST(currentExpr);
          if (!isNaN(sqrtResult) && (!useIntegerMode || isIntegerResult(sqrtResult))) result.push(currentExpr);
        }
      }
      if (operatorFlags['!'] && nums[start] >= 0 && nums[start] <= MAX_FACTORIAL_INPUT && Number.isInteger(nums[start])) {
        let currentExpr = numNode;
        for (let i = 1; i <= MAX_FACT_DEPTH && operatorFlags['!']; i++) {
          currentExpr = { type: "op", operator: "!", left: null, right: currentExpr };
          const factResult = evaluateAST(currentExpr);
          if (!isNaN(factResult)) result.push(currentExpr);
        }
      }
    } else {
      for (let i = start; i < end; i++) {
        const leftExprs = generateGroupingsHelper(start, i);
        const rightExprs = generateGroupingsHelper(i + 1, end);
        for (const left of leftExprs) {
          for (const right of rightExprs) {
            const operators = [];
            if (operatorFlags['+']) operators.push("+");
            if (operatorFlags['-']) operators.push("-");
            if (operatorFlags['*']) operators.push("*");
            if (operatorFlags['/']) operators.push("/");
            if (operatorFlags['%']) operators.push("%");
            if (operatorFlags['^']) operators.push("^");
            for (const op of operators) {
              if (op === "/" && evaluateAST(right) === 0) continue;
              if (op === "%" && evaluateAST(right) === 0) continue;
              if (op === "^" && evaluateAST(left) === 0 && evaluateAST(right) <= 0) continue;
              const newExpr = { type: "op", operator: op, left, right };
              const resultVal = evaluateAST(newExpr);
              if (isNaN(resultVal)) continue;
              if (!useIntegerMode || isIntegerResult(resultVal)) {
                result.push(newExpr);
                if (operatorFlags['√'] && getSqrtDepth(newExpr) < MAX_SQRT_DEPTH) {
                  const sqrtValue = evaluateAST(newExpr);
                  if (!isNaN(sqrtValue) && sqrtValue >= 0) {
                    let currentExpr = newExpr;
                    for (let depth = 1; depth <= MAX_SQRT_DEPTH - getSqrtDepth(newExpr); depth++) {
                      currentExpr = { type: "op", operator: "√", left: null, right: currentExpr };
                      const sqrtResult = evaluateAST(currentExpr);
                      if (!isNaN(sqrtResult) && (!useIntegerMode || isIntegerResult(sqrtResult))) {
                        result.push(currentExpr);
                      }
                    }
                  }
                }
                if (operatorFlags['!'] && getFactDepth(newExpr) < MAX_FACT_DEPTH) {
                  const factValue = evaluateAST(newExpr);
                  if (!isNaN(factValue) && factValue >= 0 && factValue <= MAX_FACTORIAL_INPUT && Number.isInteger(factValue)) {
                    let currentExpr = newExpr;
                    for (let depth = 1; depth <= MAX_FACT_DEPTH - getFactDepth(newExpr); depth++) {
                      currentExpr = { type: "op", operator: "!", left: null, right: currentExpr };
                      const factResult = evaluateAST(currentExpr);
                      if (!isNaN(factResult)) result.push(currentExpr);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    memoized.set(key, result);
    return result;
  }
  return generateGroupingsHelper(0, nums.length - 1);
}

// Flexible numeric formatting
function formatNumber(n) {
  if (Number.isInteger(n)) return n.toString();
  const s = n.toFixed(8); // high precision then trim
  return s.replace(/\.0+$/,'').replace(/(\.[0-9]*?)0+$/,'$1');
}

function findSolutions() {
  if (isCalculating) return;
  isCalculating = true;
  cancelCalculation = false;
  activeWorkers = [];

  const numContainers = document.querySelectorAll(".num-container");
  const nums = Array.from(numContainers).map(container => parseFloat(container.querySelector(".num").value)).map(v => (isNaN(v) ? 0 : v));
  const target = parseFloat(document.getElementById("target").value);

  if (isNaN(target)) {
    document.getElementById("results").innerHTML = "<h2>กรุณากรอกผลลัพธ์ที่ต้องการ</h2>";
    isCalculating = false;
    return;
  }
  if (nums.length < 2) {
    document.getElementById("results").innerHTML = "<h2>กรุณาใส่ตัวเลขอย่างน้อย 2 ตัว</h2>";
    isCalculating = false;
    return;
  }

  document.getElementById("results").innerHTML = `
    <h2>กำลังเรียงสับเปลี่ยน...</h2>
    <button id="cancel-calc-btn" onclick="cancelCalculation = true; cancelAllWorkers();">ยกเลิกการคำนวณ</button>
  `;

  if (useFastMode) findFirstSolutionFast(nums, target);
  else findAllSolutionsParallel(nums, target);
}

function findFirstSolutionFast(nums, target) {
  // ...existing code before creating workers...
  const numWorkers = navigator.hardwareConcurrency || 4;
  const workers = [];
  let found = false;
  calculationCache.clear();
  expressionCache.clear();
  const workerPromises = [];
  for (let i = 0; i < numWorkers; i++) {
    const worker = new Worker('worker.js');
    workers.push(worker);
    activeWorkers.push(worker);
    const promise = new Promise((resolve) => {
      worker.onmessage = function(e) {
        // ...existing code...
        if (e.data.found && !found) {
          const { expression, result } = e.data;
          document.getElementById("results").innerHTML = `<h2>ผลลัพธ์:</h2><ul><li>${prettyPrintExpression(expression)} = ${formatNumber(result)}</li></ul>`;
          terminateWorkers(workers);
          activeWorkers = [];
          isCalculating = false;
        } else if (e.data.closest && !found) {
          const EXACT_EPS = 1e-12;
          const { expression, result, diff } = e.data.closest;
          if (Math.abs(diff) <= EXACT_EPS) {
            document.getElementById("results").innerHTML = `
              <h2>ผลลัพธ์:</h2>
              <ul><li>${prettyPrintExpression(expression)} = ${formatNumber(result)} (ตรงเป๊ะ)</li></ul>
            `;
          } else {
            document.getElementById("results").innerHTML = `
              <h2>ไม่พบคำตอบที่ตรงเป๊ะ</h2>
              <h3>คำตอบที่ใกล้เคียงที่สุด:</h3>
              <ul><li>${prettyPrintExpression(expression)} = ${formatNumber(result)} (ห่างจากเป้าหมาย ${formatNumber(diff)})</li></ul>
            `;
          }
          terminateWorkers(workers);
          activeWorkers = [];
          isCalculating = false;
        }
        resolve();
      };
      worker.onerror = function(){ document.getElementById("results").innerHTML = "<h2>เกิดข้อผิดพลาดในการคำนวณ</h2>"; resolve(); };
    });
    workerPromises.push(promise);
    worker.postMessage({
      type: 'findFirstFast',
      nums,
      target,
      operatorFlags,
      useIntegerMode,
      MAX_SQRT_DEPTH,
      MAX_FACT_DEPTH,
      MAX_FACTORIAL_INPUT,
      speedAccuracy: fastAccuracy // NEW tuning parameter
    });
  }
  Promise.all(workerPromises).then(()=>{ if(!found) document.getElementById("results").innerHTML = "<h2>ไม่พบคำตอบที่ต้องการ</h2>"; terminateWorkers(workers); activeWorkers=[]; isCalculating=false; }).catch(()=>{ document.getElementById("results").innerHTML = "<h2>เกิดข้อผิดพลาดในการคำนวณ</h2>"; terminateWorkers(workers); activeWorkers=[]; isCalculating=false; });
}

function cancelAllWorkers() {
  activeWorkers.forEach(worker => worker.terminate());
  activeWorkers = [];
  if (isCalculating) {
    isCalculating = false;
    if (window.closestResultOnCancel) {
      const EXACT_EPS = 1e-12;
      if (Math.abs(window.closestResultOnCancel.diff) <= EXACT_EPS) {
        document.getElementById("results").innerHTML = `
          <h2>การคำนวณถูกยกเลิก</h2>
          <h3>พบคำตอบที่ตรงเป๊ะ:</h3>
          <ul><li>${prettyPrintExpression(window.closestResultOnCancel.expression)} = ${formatNumber(window.closestResultOnCancel.result)}</li></ul>`;
      } else {
        document.getElementById("results").innerHTML = `
          <h2>การคำนวณถูกยกเลิก</h2>
          <h3>คำตอบที่ใกล้เคียงที่สุด:</h3>
          <ul><li>${prettyPrintExpression(window.closestResultOnCancel.expression)} = ${formatNumber(window.closestResultOnCancel.result)} (ห่างจากเป้าหมาย ${formatNumber(window.closestResultOnCancel.diff)})</li></ul>`;
      }
    } else {
      document.getElementById("results").innerHTML = `<h2>การคำนวณถูกยกเลิก: ไม่พบคำตอบใดๆ</h2>`;
    }
  }
}

function findAllSolutionsParallel(nums, target) {
  const permutations = permute(nums);
  const totalPerms = permutations.length;
  if (totalPerms === 0) { document.getElementById("results").innerHTML = "<h2>ไม่พบคำตอบใดๆ</h2>"; isCalculating = false; return; }
  const numWorkers = navigator.hardwareConcurrency || 4;
  calculationCache.clear(); expressionCache.clear();
  activeWorkers.forEach(w=>w.terminate()); activeWorkers=[];

  let results = []; let expressionSet = new Set();
  let closestResult = null; let smallestDiff = Infinity;
  let nextIndex = 0; // next permutation index to assign
  let baseBatchSize = 4; // starting batch size (perms per assignment)
  const maxBatchSize = 64;
  let completedPerms = 0; // fully processed permutations
  const inProgress = new Map(); // worker -> processed inside its current batch
  let workersFinished = 0; // workers that became idle after queue drained
  const EXACT_EPS = 1e-12;
  let lastUIUpdate = 0;

  document.getElementById("results").innerHTML = `
    <h2>กำลังคำนวณ... 0% (0/${totalPerms})</h2>
    <p>ผลลัพธ์ที่ใกล้เคียงที่สุด: ยังไม่พบ</p>
    <button id="cancel-calc-btn" onclick="cancelCalculation = true; cancelAllWorkers();">ยกเลิกการคำนวณ</button>
  `;

  function adaptiveBatchSize(){
    // Simple growth: enlarge when >50% queue remaining processed quickly
    if (baseBatchSize < maxBatchSize) baseBatchSize = Math.min(maxBatchSize, baseBatchSize * 2);
  }

  function aggregateProcessed(){
    let inProgSum = 0; inProgress.forEach(v=> inProgSum += v);
    return completedPerms + inProgSum;
  }

  function updateUI(force=false){
    const now = performance.now(); if(!force && now - lastUIUpdate < 80) return; lastUIUpdate = now;
    const processed = aggregateProcessed();
    const percent = Math.round((processed/totalPerms)*100);
    let closestText = "ยังไม่พบ";
    if (closestResult){
      if (Math.abs(closestResult.diff) <= EXACT_EPS) closestText = `${prettyPrintExpression(closestResult.expression)} = ${formatNumber(closestResult.result)} (ตรงเป๊ะ)`;
      else closestText = `${prettyPrintExpression(closestResult.expression)} = ${formatNumber(closestResult.result)} (ห่างจากเป้าหมาย ${formatNumber(closestResult.diff)})`;
    }
    document.getElementById("results").innerHTML = `
      <h2>กำลังคำนวณ... ${percent}% (${processed}/${totalPerms})</h2>
      <p>ผลลัพธ์ที่ใกล้เคียงที่สุด: ${closestText}</p>
      <button id="cancel-calc-btn" onclick="cancelCalculation = true; cancelAllWorkers();">ยกเลิกการคำนวณ</button>
    `;
  }

  function finalizeIfDone(){
    if (completedPerms >= totalPerms && inProgress.size===0){
      // all permutations processed
      if (results.length > 0){ displayResults(results); }
      else if (closestResult){
        if (Math.abs(closestResult.diff) <= EXACT_EPS){
          document.getElementById("results").innerHTML = `
            <h2>พบคำตอบที่ตรงเป๊ะ:</h2>
            <ul><li>${prettyPrintExpression(closestResult.expression)} = ${formatNumber(closestResult.result)}</li></ul>`;
        } else {
          const diff = Math.abs(closestResult.result - target).toPrecision(8);
          document.getElementById("results").innerHTML = `
            <h2>คำตอบที่ใกล้เคียงที่สุด:</h2>
            <ul><li>${prettyPrintExpression(closestResult.expression)} = ${formatNumber(closestResult.result)} (ห่างจากเป้าหมาย ${diff})</li></ul>`;
        }
      } else {
        document.getElementById("results").innerHTML = "<h2>ไม่พบคำตอบที่ใช้ตัวเลขทั้งหมด</h2>";
      }
      activeWorkers.forEach(w=>w.terminate()); activeWorkers=[]; isCalculating=false; return true;
    }
    return false;
  }

  function assignBatch(worker){
    if (cancelCalculation) return; if (nextIndex >= totalPerms){ return; }
    const start = nextIndex; const size = Math.min(baseBatchSize, totalPerms - nextIndex); const end = start + size; nextIndex = end; inProgress.set(worker,0); worker._batchStart=start; worker._batchEnd=end; worker.postMessage({ type:'findAllRange', permutations, start, end, target, nums, operatorFlags, useIntegerMode, MAX_SQRT_DEPTH, MAX_FACT_DEPTH, MAX_FACTORIAL_INPUT, MAX_RESULTS: Infinity });
    if (nextIndex < totalPerms) adaptiveBatchSize();
  }

  for(let w=0; w<numWorkers; w++){
    const worker = new Worker('worker.js'); activeWorkers.push(worker);
    worker.onmessage = function(e){ if(cancelCalculation) return; const data=e.data;
      if (data.progress){
        // data.processed is within current batch (1..batchSize)
        inProgress.set(worker, Math.min(data.processed, (worker._batchEnd - worker._batchStart)));
        if (data.closest && (!closestResult || data.closest.diff < smallestDiff)) { smallestDiff=data.closest.diff; closestResult=data.closest; window.closestResultOnCancel=closestResult; }
        updateUI();
        return;
      }
      if (data.results){
        data.results.forEach(res=>{ if(!expressionSet.has(res.expression)){ expressionSet.add(res.expression); results.push(res);} });
      }
      if (data.closest && (!closestResult || data.closest.diff < smallestDiff)) { smallestDiff=data.closest.diff; closestResult=data.closest; window.closestResultOnCancel=closestResult; }
      // batch finished
      const batchSize = (worker._batchEnd - worker._batchStart);
      completedPerms += batchSize; inProgress.delete(worker);
      updateUI(true);
      if (finalizeIfDone()) return;
      assignBatch(worker);
      if (nextIndex >= totalPerms && !inProgress.has(worker)){ // no more work assigned to this worker
        workersFinished++;
      }
    };
    worker.onerror = function(){ inProgress.delete(worker); completedPerms += (worker._batchEnd - worker._batchStart)||0; updateUI(true); if(!finalizeIfDone()) assignBatch(worker); };
    assignBatch(worker);
  }
}

function permute(arr) {
  const seen = new Set();
  const permutations = [];
  const c = new Array(arr.length).fill(0);
  let i = 1;
  const initial = arr.slice();
  const key = initial.join(",");
  seen.add(key);
  permutations.push(initial);
  while (i < arr.length) {
    if (c[i] < i) {
      const swapIndex = i % 2 ? c[i] : 0;
      [arr[swapIndex], arr[i]] = [arr[i], arr[swapIndex]];
      const key = arr.join(",");
      if (!seen.has(key)) {
        seen.add(key);
        permutations.push(arr.slice());
      }
      c[i]++;
      i = 1;
    } else {
      c[i] = 0;
      i++;
    }
  }
  return permutations;
}

function terminateWorkers(workers) {
  workers.forEach(worker => worker.terminate());
}

function usesAllNumbers(ast, originalNums) {
  const numbers = [];
  function extractNumbers(node) {
    if (node.type === "num") numbers.push(node.value);
    if (node.left) extractNumbers(node.left);
    if (node.right) extractNumbers(node.right);
  }
  extractNumbers(ast);
  if (numbers.length !== originalNums.length) return false;
  const sortedUsed = [...numbers].sort((a, b) => a - b);
  const sortedOriginal = [...originalNums].sort((a, b) => a - b);
  const EPS = 1e-9;
  for (let i = 0; i < sortedUsed.length; i++) {
    if (Math.abs(sortedUsed[i] - sortedOriginal[i]) > EPS) return false;
  }
  return true;
}

function respectsLockOrder(ast, originalNums, lockedIndices) {
  const numberPositions = [];
  function extractPositions(node, position = []) {
    if (node.type === "num") numberPositions.push({ value: node.value, position: [...position] });
    if (node.left) extractPositions(node.left, [...position, 'left']);
    if (node.right) extractPositions(node.right, [...position, 'right']);
  }
  extractPositions(ast);
  const originalPositions = new Map();
  originalNums.forEach((num, index) => originalPositions.set(index, num));
  for (const lockedIndex of lockedIndices) {
    const lockedNum = originalNums[lockedIndex];
    const lockedPosInAST = numberPositions.find(np => np.value === lockedNum);
    if (!lockedPosInAST) return false;
    const allPositions = numberPositions.map(np => np.position.length);
    const maxDepth = Math.max(...allPositions);
    const lockedDepth = lockedPosInAST.position.length;
    if (lockedIndex === originalNums.length - 1) {
      if (lockedDepth !== maxDepth || numberPositions.filter(np => np.position.length === maxDepth).length > 1) return false;
    } else if (lockedIndex === 0) {
      if (lockedDepth !== 0) return false;
    } else {
      const beforeLocked = originalNums.slice(0, lockedIndex);
      const afterLocked = originalNums.slice(lockedIndex + 1);
      const beforeCount = numberPositions.filter(np => beforeLocked.includes(np.value) && np.position.length < lockedDepth).length;
      const afterCount = numberPositions.filter(np => afterLocked.includes(np.value) && np.position.length > lockedDepth).length;
      if (beforeCount !== beforeLocked.length || afterCount !== afterLocked.length) return false;
    }
  }
  return true;
}

function updateProgress(processed, total, target, results, closestResult) {
  const percent = Math.round((processed / total) * 100);
  let closestText = "ยังไม่พบ";
  const EXACT_EPS = 1e-12;
  if (closestResult) {
    if (Math.abs(closestResult.diff) <= EXACT_EPS) {
      closestText = `${prettyPrintExpression(closestResult.expression)} = ${formatNumber(closestResult.result)} (ตรงเป๊ะ)`;
    } else {
      closestText = `${prettyPrintExpression(closestResult.expression)} = ${formatNumber(closestResult.result)} (ห่างจากเป้าหมาย ${formatNumber(closestResult.diff)})`;
    }
  }
  document.getElementById("results").innerHTML = `
    <h2>กำลังคำนวณ... ${percent}% (${processed}/${total})</h2>
    <p>ผลลัพธ์ที่ใกล้เคียงที่สุด: ${closestText}</p>
    <button id="cancel-calc-btn" onclick="cancelCalculation = true; cancelAllWorkers();">ยกเลิกการคำนวณ</button>
  `;
}

function prettyPrintExpression(expr) {
  let s = expr
    .replace(/\( *([^\(\)]+) *\)!/g, '$1!')
    .replace(/√\(([^(\)]+)\)/g, '√$1');
  s = s.replace(/\(([^(\)]+)\s\^\s([^\(\)]+)\)/g, '$1^$2');
  s = s.replace(/\*/g, '×').replace(/\//g, '÷').replace(/%/g, ' mod ');
  s = s.replace(/\(([0-9]+)\)/g, '$1');
  while (
    s.startsWith('(') &&
    s.endsWith(')') &&
    (() => {
      let depth = 0;
      for (let i = 0; i < s.length; ++i) {
        if (s[i] === '(') depth++;
        if (s[i] === ')') depth--;
        if (depth === 0 && i < s.length - 1) return false;
      }
      return depth === 0;
    })()
  ) {
    s = s.slice(1, -1);
  }
  s = s.replace(/\s+/g, ' ').replace(/\( /g, '(').replace(/ \)/g, ')');
  return s;
}

function displayResults(results) {
  if (results.length > 0) {
    document.getElementById("results").innerHTML =
      `<h2>ผลลัพธ์ (${results.length} รายการ):</h2><ul>` +
      results.map((res) => `<li>${prettyPrintExpression(res.expression)} = ${formatNumber(res.result)}</li>`).join("") +
      `</ul>`;
  } else if (window.closestResultOnCancel) {
    const target = parseFloat(document.getElementById("target").value);
    const EXACT_EPS = 1e-12;
    const diffRaw = Math.abs(window.closestResultOnCancel.result - target);
    if (diffRaw <= EXACT_EPS) {
      document.getElementById("results").innerHTML = `
        <h2>พบคำตอบที่ตรงเป๊ะ:</h2>
        <ul><li>${prettyPrintExpression(window.closestResultOnCancel.expression)} = ${formatNumber(window.closestResultOnCancel.result)}</li></ul>`;
    } else {
      const diff = diffRaw.toPrecision(8);
      document.getElementById("results").innerHTML = `
        <h2>คำตอบที่ใกล้เคียงที่สุด:</h2>
        <ul><li>${prettyPrintExpression(window.closestResultOnCancel.expression)} = ${formatNumber(window.closestResultOnCancel.result)} (ห่างจากเป้าหมาย ${diff})</li></ul>`;
    }
  } else {
    document.getElementById("results").innerHTML = "<h2>ไม่พบคำตอบที่ใช้ตัวเลขทั้งหมด</h2>";
  }
}

// Initialize
addNumber();
// Ensure initial input supports decimals
const firstNum = document.querySelector('.num');
if (firstNum) firstNum.step = 'any';

// Initialize WebAssembly status monitoring
async function initializeWASM() {
  const statusText = document.getElementById('wasm-status-text');
  const statusIcon = document.getElementById('wasm-status-icon');
  const statusDesc = document.querySelector('.status-description');
  
  try {
    await window.wasmMath.initPromise;
    
    if (window.wasmMath.isReady) {
      statusText.textContent = 'WebAssembly พร้อมใช้งาน (add, sub, mul, div, sqrt)';
      statusIcon.className = 'status-icon ready';
      statusIcon.textContent = '✓';
      statusDesc.textContent = 'WebAssembly ช่วยเพิ่มความเร็วการคำนวณทางคณิตศาสตร์ทั้ง 5 operations';
    } else {
      throw new Error(window.wasmMath.errorMessage || 'WebAssembly ไม่สามารถเริ่มต้นได้');
    }
  } catch (error) {
    statusText.textContent = 'ใช้ JavaScript fallback';
    statusIcon.className = 'status-icon fallback';
    statusIcon.textContent = '⚠';
    
    if (window.wasmMath.errorMessage) {
      statusDesc.innerHTML = `
        <strong>สาเหตุ:</strong> ${window.wasmMath.errorMessage}<br>
        <em>ระบบจะใช้ JavaScript ในการคำนวณแทน</em>
      `;
    } else {
      statusDesc.textContent = 'ระบบจะใช้ JavaScript ในการคำนวณแทน';
    }
  }
}

// Initialize WASM status
initializeWASM();

// Set initial button states
document.getElementById("toggleAddBtn").textContent = "ปิดการใช้ +";
document.getElementById("toggleSubBtn").textContent = "ปิดการใช้ -";
document.getElementById("toggleMulBtn").textContent = "ปิดการใช้ ×";
document.getElementById("toggleDivBtn").textContent = "ปิดการใช้ ÷";

// Improved drag logic with robust mobile support & page sync
function initNavDrag(){
  const switchEl = document.querySelector('.nav-glass-switch');
  const blob = switchEl?.querySelector('.nav-blob');
  if(!switchEl || !blob) return;
  const buttons = Array.from(switchEl.querySelectorAll('.nav-btn'));
  let dragging=false; let startX=0; let blobStart=0; let activeIndex = buttons.findIndex(b=>b.classList.contains('active')) || 0; let currentIndex=activeIndex; let pointerId=null; let framePending=false;

  function clamp(v,min,max){return Math.max(min,Math.min(max,v));}
  function setActive(i){ buttons.forEach(b=>b.classList.remove('active')); const btn=buttons[i]; if(btn){ btn.classList.add('active'); showPage(btn.dataset.target, btn); } }
  function positionBlobTo(i, animate=true){ const btn=buttons[i]; if(!btn) return; const rect=btn.getBoundingClientRect(); const parentRect=switchEl.getBoundingClientRect(); const left = rect.left - parentRect.left; blob.style.width = rect.width + 'px'; if(!animate) switchEl.classList.add('dragging'); blob.style.setProperty('--blob-x', left + 'px'); if(animate){ switchEl.classList.remove('dragging'); } }
  positionBlobTo(activeIndex,false);

  function pointerDown(e){ if(dragging) return; if(e.type==='mousedown' && e.button!==0) return; const targetBtn = e.target.closest('.nav-btn'); if(!targetBtn) return; pointerId = e.pointerId || (e.touches? e.touches[0].identifier: 'touch'); dragging=true; switchEl.classList.add('dragging'); const parentRect = switchEl.getBoundingClientRect(); startX = (e.touches? e.touches[0].clientX : e.clientX); const blobRect = blob.getBoundingClientRect(); blobStart = blobRect.left - parentRect.left; currentIndex = buttons.indexOf(targetBtn); e.preventDefault(); }
  function pointerMove(e){ if(!dragging) return; const clientX = (e.touches? e.touches[0].clientX : e.clientX); const parentRect = switchEl.getBoundingClientRect(); const delta = clientX - startX; const rawX = blobStart + delta; const maxX = parentRect.width - blob.offsetWidth - 4; const x = clamp(rawX, 0, maxX); blob.style.setProperty('--blob-x', x + 'px'); if(framePending) return; framePending=true; requestAnimationFrame(()=>{ framePending=false; // determine nearest index based on center
      const blobCenter = x + blob.offsetWidth/2; let nearest = 0; let best=Infinity; buttons.forEach((btn,i)=>{ const r=btn.getBoundingClientRect(); const c = r.left - parentRect.left + r.width/2; const d=Math.abs(c-blobCenter); if(d<best){ best=d; nearest=i; }}); currentIndex = nearest; }); }
  function pointerUp(){ if(!dragging) return; dragging=false; switchEl.classList.remove('dragging'); positionBlobTo(currentIndex,true); if(currentIndex!==activeIndex){ activeIndex=currentIndex; setActive(activeIndex); } else { // ensure sync even if same index
    setActive(activeIndex);
  } }
  function cancelDrag(){ if(!dragging) return; dragging=false; switchEl.classList.remove('dragging'); positionBlobTo(activeIndex,true); }

  switchEl.addEventListener('mousedown', pointerDown, {passive:false});
  switchEl.addEventListener('touchstart', pointerDown, {passive:false});
  window.addEventListener('mousemove', pointerMove, {passive:false});
  window.addEventListener('touchmove', pointerMove, {passive:false});
  window.addEventListener('mouseup', pointerUp, {passive:false});
  window.addEventListener('touchend', pointerUp, {passive:false});
  window.addEventListener('touchcancel', cancelDrag, {passive:false});
  window.addEventListener('mouseleave', cancelDrag);
  window.addEventListener('resize', ()=> positionBlobTo(activeIndex,true));
}
window.addEventListener('load', initNavDrag);
    </script>
</body>
</html>